<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-96x96.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png?v=2.6.2" sizes="180x180"><link rel="mask-icon" href="/images/icons/stun-logo.svg?v=2.6.2" color="#54bcff"><meta name="msapplication-TileImage" content="/images/icons/favicon-144x144.png"><meta name="msapplication-TileColor" content="#000000"><meta name="msvalidate.01" content="16024CC771E07E05BB6EB2B4C522B897"><meta name="baidu-site-verification" content="code-xh2oqTvRGY"><meta name="description" content="扫雷主体部分的c++代码实现，以及Qt的简单介绍，并且通过Qt来实现扫雷游戏的图形化，鼠标点击时间的判断，信号与槽的使用，以及游戏难度的选择以及自定义和记录时间功能的添加。                      一、主体函数的C++实现                             1.游戏的初始化        最简单的扫雷游戏是一个9×9的方块，因此，我们可以建立一个9×"><meta property="og:type" content="article"><meta property="og:title" content="C++图形化扫雷"><meta property="og:url" content="https://voyage-li.github.io/2021/08/16/mine-sweep/index.html"><meta property="og:site_name" content="Twilight"><meta property="og:description" content="扫雷主体部分的c++代码实现，以及Qt的简单介绍，并且通过Qt来实现扫雷游戏的图形化，鼠标点击时间的判断，信号与槽的使用，以及游戏难度的选择以及自定义和记录时间功能的添加。                      一、主体函数的C++实现                             1.游戏的初始化        最简单的扫雷游戏是一个9×9的方块，因此，我们可以建立一个9×"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-08-15T16:00:00.000Z"><meta property="article:modified_time" content="2021-08-15T16:00:00.000Z"><meta property="article:author" content="voyage"><meta property="article:tag" content="GUI"><meta property="article:tag" content="Qt"><meta property="article:tag" content="DFS"><meta name="twitter:card" content="summary"><title>C++图形化扫雷 | Twilight</title><link ref="canonical" href="https://voyage-li.github.io/2021/08/16/mine-sweep/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:void 0,fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"20px",tocMaxDepth:6},header:void 0,postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},codeblock:{style:"carbon",highlight:"light",wordWrap:!1},reward:!1,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:void 0,lazyload:!0,pjax:{avoidBanner:!0},externalLink:void 0,shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"复制成功",copyError:"复制失败"},sourcePath:{js:"js",css:"css",images:"images"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Twilight" type="application/atom+xml"></head><body><div id="loader-wrapper"><div id="loader"></div><div class="loader-section section-left"></div><div class="loader-section section-right"></div></div><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-database"></i></span><span class="header-nav-menu-item__text">统计</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/message/"><span class="header-nav-menu-item__icon"><i class="fas fa-comment"></i></span><span class="header-nav-menu-item__text">留言</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/history/"><span class="header-nav-menu-item__icon"><i class="fa fa-history"></i></span><span class="header-nav-menu-item__text">历史</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">C++图形化扫雷</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.2k</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2021/08/16/mine-sweep/" data-flag-title="C++图形化扫雷"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><p>    扫雷主体部分的c++代码实现，以及Qt的简单介绍，并且通过Qt来实现扫雷游戏的图形化，鼠标点击时间的判断，信号与槽的使用，以及游戏难度的选择以及自定义和记录时间功能的添加。</p><h3 id="一-主体函数的c实现"><a href="#一-主体函数的c实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一-主体函数的c实现"></a> 一、主体函数的C++实现</h3><h4 id="1游戏的初始化"><a href="#1游戏的初始化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1游戏的初始化"></a> 1.游戏的初始化</h4><p>最简单的扫雷游戏是一个9×9的方块，因此，我们可以建立一个9×9的二维数组，先对其进行初始化，然后，在其中存储相关的数据。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 9</span></span><br><span class="line"><span class="keyword">int</span> gamedata[ROW][COL]; <span class="comment">//记录原始数据</span></span><br><span class="line"><span class="built_in">memset</span>(gamedata, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(gamedata));</span><br></pre></td></tr></table></div></figure><p>不同状态的记录，扫雷游戏每一个小块的状态可以对应表示成的不同的数字。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0~8 该方块周围的雷的数量</span></span><br><span class="line"><span class="comment">//88 该方块为雷</span></span><br><span class="line"><span class="comment">//777 该方块处于待点击状态</span></span><br></pre></td></tr></table></div></figure><span id="more"></span><p>雷的生成，简单的扫雷游戏中，会在9×9的81方块中随机生成10个雷，转化成计算机的语言就是，从1~81中任意取10个数，但是这样的选取有一定的缺点，在我们取出随机数之后，我们很难将随机数与相应的雷产生联系，带来了不必要的麻烦，解决方案是，我们可以生成十组横纵坐标1~9之间的随机数（避免重复的情况），这样下来，随机数的选取和雷的位置对应能够更加的简单，代码实现如下：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOM_NUM 10</span></span><br><span class="line"><span class="keyword">int</span> boom_num_now = <span class="number">0</span>; <span class="comment">//已经生成的雷的数量</span></span><br><span class="line"><span class="keyword">while</span> (boom_num_now != BOOM_NUM)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里随机数使用了QRandomGenerator头文件中的函数</span></span><br><span class="line">    <span class="keyword">int</span> x=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">0</span>,ROW);   </span><br><span class="line">    <span class="keyword">int</span> y=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">0</span>,COL);</span><br><span class="line">    <span class="keyword">if</span> (gamedata[x][y] == <span class="number">88</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gamedata[x][y] = <span class="number">88</span>;</span><br><span class="line">    boom_num_now++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>每一个方块周围雷数量的统计，通过一个循环来计数即可：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (gamedata[i][j] == <span class="number">88</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = i - <span class="number">1</span>; dx &lt;= i + <span class="number">1</span>; dx++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy = j - <span class="number">1</span>; dy &lt;= j + <span class="number">1</span>; dy++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dx &lt; ROW &amp;&amp; dy &lt; COL &amp;&amp; gamedata[dx][dy] == <span class="number">88</span>)</span><br><span class="line">                     tmp++;</span><br><span class="line">             &#125;</span><br><span class="line">         gamedata[i][j] = tmp;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></div></figure><p>生成一个向玩家展示的数组，来记录每一点击产生的结果，如下所示：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> view[ROW][COL];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">        view[i][j] = <span class="number">777</span>;</span><br></pre></td></tr></table></div></figure><h4 id="2鼠标点击事件的判断"><a href="#2鼠标点击事件的判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2鼠标点击事件的判断"></a> 2.鼠标点击事件的判断</h4><p>鼠标点击一个方块，即选择了对应左边的数据，如果选中了雷，那么游戏结束，如果选中了其他方块，则需要判断其周围有没有雷，以此来翻开其它的方块，其本质是一个深度搜索(<code>DFS</code>)，我们可以通过递归来完成这个过程，具体的思想是：</p><p>先通过循环判断点击方块一周的方块是否有雷，如果没有雷的话，就相当于我们点击了周围一圈的方块，可以直接递归调用该函数，递归返回的条件分为两种，一种是该方块已经翻开，一种是该方块周围有雷的存在，具体的代码实现如下所示：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (view[x][y] != <span class="number">777</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    view[x][y] = gamedata[x][y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dx = x - <span class="number">1</span>; dx &lt;= x + <span class="number">1</span>; dx++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = y - <span class="number">1</span>; dy &lt;= y + <span class="number">1</span>; dy++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; ROW &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; COL)</span><br><span class="line">                <span class="keyword">if</span> (gamedata[dx][dy] == <span class="number">88</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = x - <span class="number">1</span>; dx &lt;= x + <span class="number">1</span>; dx++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy = y - <span class="number">1</span>; dy &lt;= y + <span class="number">1</span>; dy++)</span><br><span class="line">                <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; ROW &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; COL)</span><br><span class="line">                    <span class="built_in">dfs</span>(dx, dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="3游戏胜利的条件判断"><a href="#3游戏胜利的条件判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3游戏胜利的条件判断"></a> 3.游戏胜利的条件判断</h4><p>扫雷游戏的胜利条件判断较为简单，如果剩余的没有点击的方块数量（没有点击或者已经被标记）和雷数相同，就表示游戏取得了胜利，代码实现如下：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">whetherwin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (view[i][j] == <span class="number">777</span>)</span><br><span class="line">                temp++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp == BOOM_NUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>至此，就完成了整个扫雷游戏的主体函数部分，再加上输入输出函数，和一些额外条件的判断，就可以得到一个基本的命令行版本的扫雷游戏。</p><h3 id="二-从c过渡到qt"><a href="#二-从c过渡到qt" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二-从c过渡到qt"></a> 二、从C++过渡到Qt</h3><h4 id="1窗口的搭建"><a href="#1窗口的搭建" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1窗口的搭建"></a> 1.窗口的搭建</h4><p>打开Qt creator,新建一个Qt Widgets Application，点击mainwindow.ui进入设计界面，通过拖动左栏的窗口控件，完成图形化窗口的搭建。</p><h4 id="2扫雷界面的绘制"><a href="#2扫雷界面的绘制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2扫雷界面的绘制"></a> 2.扫雷界面的绘制</h4><p><code>QPixmap</code>头文件中主要用来绘图的函数是<code>drawPixmap()</code>,根据Qt官方文档的描述，<code>drawPixmap()</code>,有多种重载函数，由于为扫雷游戏准备的资源文件已经是确定了像素的，只需要对绘图的位置和不同的图片进行选择，所以选择以下所示的重载函数。</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">QPainter::drawPixmap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> QPixmap &amp;pm)</span><span class="comment">// x,y表示需要绘图位置的坐标，pm是需要绘制的图片&#123;    drawPixmap(QPointF(x, y), pm);&#125;</span></span></span><br></pre></td></tr></table></div></figure><p>使用循环，在<code>paitEvent()</code>内调用<code>drawPixmap()</code>函数即可绘制主要的窗口：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_HEIGHT 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_WIDTH 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MENU_WIDTH 26+40</span></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COL; j++)        </span><br><span class="line">        painter.<span class="built_in">drawPixmap</span>(i * BLOCK_HEIGHT, MENU_WIDTH + j * BLOCK_WIDTH, view[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="3鼠标点击事件的具体实现"><a href="#3鼠标点击事件的具体实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3鼠标点击事件的具体实现"></a> 3.鼠标点击事件的具体实现</h4><p>根据Qt官方文档，和鼠标点击相关的头文件是<code>QMouseEvent</code>，官方文档内，对获取鼠标点击位置的描述函数是：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qRound</span>(l.<span class="built_in">x</span>()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qRound</span>(l.<span class="built_in">y</span>()); &#125;</span><br></pre></td></tr></table></div></figure><p>这样得到的位置坐标是对应的像素坐标，我们知道每一个方块的边长，通过取余数的方式可以获得具体的在扫雷游戏中的坐标</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = event-&gt;<span class="built_in">x</span>() / BLOCK_WIDTH;</span><br><span class="line"><span class="keyword">int</span> y = (event-&gt;<span class="built_in">y</span>() - MENU_WIDTH) / BLOCK_HEIGHT; <span class="comment">//需要剪掉菜单栏的距离</span></span><br></pre></td></tr></table></div></figure><p>在实际游戏时，鼠标左右键点击的效果不同，<code>QMouseEvent</code>中对鼠标点击事件的描述是</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Qt::MouseButton <span class="title">button</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> b; &#125;</span><br></pre></td></tr></table></div></figure><p>该函数会返回一个枚举类型，对应着不同的鼠标点击，具体的实现如下：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::RightButton) &#123;&#125;</span><br></pre></td></tr></table></div></figure><h4 id="4点击数字功能实现"><a href="#4点击数字功能实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#4点击数字功能实现"></a> 4.点击数字功能实现</h4><p>Windows平台的扫雷游戏中，用户可以点击已被翻开的数字方块，如果周围所有的雷已被标记，则可以直接翻开未被标记的方块，如果标记雷的数量是正确的，但是标记的具体方块是错误的，则会直接导致游戏结束，如果已经标记的雷的数量和点击数字方块的数字不同，则直接等待下一次用户的操作。</p><p>实现该功能的思路是，先判断鼠标左键点击的位置，得到该方块周围雷的数量，然后循环周围已经被标记的雷的数量，以及标记的是否正确，如果标记错误，则可以直接触发游戏结束命令，如果标记正确且和对应的雷数量相同，则调用上文已经叙述过的<code>dfs()</code>函数，翻开方块，代码的具体实现如下所示：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton &amp;&amp; mine-&gt;view[x][y] != <span class="number">777</span> &amp;&amp; mine-&gt;view[x][y] != <span class="number">-1</span>)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">int</span> aim = mine-&gt;view[x][y];    </span><br><span class="line">    <span class="keyword">int</span> temp_flag = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dx = x - <span class="number">1</span>; dx &lt;= x + <span class="number">1</span>; dx++)        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = y - <span class="number">1</span>; dy &lt;= y + <span class="number">1</span>; dy++)            </span><br><span class="line">            <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; mine-&gt;<span class="built_in">getrow</span>() &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; mine-&gt;<span class="built_in">getcolumn</span>())            </span><br><span class="line">            &#123;               </span><br><span class="line">                <span class="keyword">if</span> (mine-&gt;view[dx][dy] == <span class="number">-1</span> &amp;&amp; mine-&gt;gamedata[dx][dy] != <span class="number">88</span>)                    </span><br><span class="line">                    error = <span class="number">1</span>;                </span><br><span class="line">                <span class="keyword">if</span> (mine-&gt;view[dx][dy] == <span class="number">-1</span>)                </span><br><span class="line">                &#123;                    </span><br><span class="line">                    temp_flag++;</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;    </span><br><span class="line">    <span class="keyword">if</span> (temp_flag == aim)    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (error == <span class="number">1</span>)        </span><br><span class="line">        &#123;            </span><br><span class="line">            gameover = <span class="literal">true</span>;            </span><br><span class="line">            runtime-&gt;<span class="built_in">stop</span>();            </span><br><span class="line">            gamestart = <span class="number">1</span>;            </span><br><span class="line">            alreadyflag = <span class="number">0</span>;            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mine-&gt;<span class="built_in">getrow</span>(); i++)                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mine-&gt;<span class="built_in">getcolumn</span>(); j++)                </span><br><span class="line">                &#123;                    </span><br><span class="line">                    <span class="keyword">if</span> (mine-&gt;view[i][j] == <span class="number">-1</span> &amp;&amp; mine-&gt;gamedata[i][j] != <span class="number">88</span>)                        </span><br><span class="line">                        mine-&gt;gamedata[i][j] = <span class="number">-777</span>;                </span><br><span class="line">                &#125;            </span><br><span class="line">            <span class="built_in">repaint</span>();            </span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = x - <span class="number">1</span>; dx &lt;= x + <span class="number">1</span>; dx++)            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy = y - <span class="number">1</span>; dy &lt;= y + <span class="number">1</span>; dy++)                </span><br><span class="line">                <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; mine-&gt;<span class="built_in">getrow</span>() &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; mine-&gt;<span class="built_in">getcolumn</span>())                </span><br><span class="line">                &#123;                    </span><br><span class="line">                    <span class="keyword">if</span> (mine-&gt;view[dx][dy] == <span class="number">777</span>)                    </span><br><span class="line">                    &#123;                        </span><br><span class="line">                        <span class="built_in">dfs</span>(dx, dy);                        </span><br><span class="line">                        <span class="built_in">repaint</span>();                    </span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="5程序的执行步骤"><a href="#5程序的执行步骤" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#5程序的执行步骤"></a> 5.程序的执行步骤</h4><ul><li>用户开始选择开始游戏，程序自动产生两个数组：<code>gamedata</code>和<code>view</code></li><li>程序自动给<code>gamedata</code>进行初始化，<code>view</code>的值则全部设置成为UNKNOWN，即尚未打开状态，程序根据数组<code>view</code>，将当前的游戏状态通过<code>drawPixmap()</code>绘制到窗口上</li><li>用户点击窗口，触发<code>QMouseEvent</code>，进入函数进行相应的判断，根据鼠标的左右键点击的不同，进入不同的分支</li><li>同时每次触发完鼠标点击时间之后，都进行一次是否获胜的判断。同时，定义<code>bool</code>类型的全局变量<code>gameover</code>，如果游戏已经失败或者已经z取胜，则将<code>gameover</code>设置为true，不再进入鼠标点击时间的判断。</li></ul><h3 id="三-额外功能的实现"><a href="#三-额外功能的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#三-额外功能的实现"></a> 三、额外功能的实现</h3><h4 id="1不同难度的选择和自定义"><a href="#1不同难度的选择和自定义" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1不同难度的选择和自定义"></a> 1.不同难度的选择和自定义</h4><ul><li><p>传统扫雷游戏可以选择不同的难度，此次实现的扫雷游戏应该也有这个功能。为了实现这一功能，可以定义一个<code>block</code>类，以此来储存不同情况下的横宽以及雷的数量，同时，由于不同的情况下，<code>gamedata</code>和<code>view</code>的初始化不同，所以游戏的初始化也应该放在<code>block</code>类中完成。</p></li><li><p><code>block</code>类中主要定义了：扫雷游戏的长，扫雷游戏的高，扫雷游戏雷的数量，当前已经经过的时间。同时上述的成员均为<code>private</code>成员，所以同时需要定义<code>public</code>的成员函数，来一一对应，获得上述对象的值。</p></li><li><p>在整个游戏开始时，先建立一个<code>block</code>类的指针，其中第一次进入消息循环时，使用初级难度作为初始化的值、在用户选择不同难度的时侯，可以通过传给指针不同的地址，来进行处理。</p></li><li><p>首先类需要处理的是游戏的初始化，由于需要根据类的构造函数来创建数组，所以显然需要动态申请内存空间，这里可以在类中定义二维指针，然后通过<code>new</code>来动态开辟内存空间，具体实现如下（这里只展示其中一个数组的初始化方法，另外一个数组的初始化方法完全相同）：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">view = <span class="keyword">new</span> <span class="keyword">int</span> *[row];<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)    </span><br><span class="line">    view[i] = <span class="keyword">new</span> <span class="keyword">int</span>[column];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)    </span><br><span class="line">    &#123;        </span><br><span class="line">        gamedata[i][j] = <span class="number">0</span>;        </span><br><span class="line">        view[i][j] = <span class="number">777</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure></li><li><p>实现用户自定义游戏难度即是要接收用户输入的数据，可以通过新建一个窗口来接收数据，但在接收数据的途中，需要注意用户输入数据的合理性。行和列数不能为负或者过大，以及用户输入的雷的数量不能多于用户输入的行列数乘积，否则会造成非法访问的问题，导致程序异常退出。</p></li></ul><h4 id="2剩余雷数量的计算以及呈现"><a href="#2剩余雷数量的计算以及呈现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2剩余雷数量的计算以及呈现"></a> 2.剩余雷数量的计算以及呈现</h4><p>全局变量<code>alreadyflag</code>来记录已经被鼠标左键标记的雷的数量，同时每次检测到鼠标左键点击的时候，根据情况的不同，即时更改，同时，在每轮游戏结束时，将<code>alreadyflag</code>变量重新初始化。</p><p>雷的数量的绘制也应写在<code>paintEvent()</code>内部，获得剩余雷的数量之后，使用分支语句，直接将数字呈现给用户。需要注意的是，为了防止用户标记的雷的数量超过游戏本生雷的数量，所以在绘制前需要判断是否剩余未标记雷的数量为负值</p><h4 id="3游戏时间记录与绘制"><a href="#3游戏时间记录与绘制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3游戏时间记录与绘制"></a> 3.游戏时间记录与绘制</h4><p>Qt中与时间有关的头文件主要有<code>QTimer</code>，新建一个<code>QTimer</code>对象，通过调用<code>start()</code>函数控制Qt计时器的开始以及时间间隔，通过<code>connect()</code>函数，连接<code>timeout()</code>信号与自定义的槽函数，随着时间的变化执行相应的不同操作。</p><p>记录时间变化的槽函数可以使用<code>block</code>类的成员函数，在<code>block</code>类中初始化一<code>private</code>类型的时间变量，每次调用槽函数使该变量递增，即可记录当前时间，具体的代码实现如下：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cppblock </span></span><br><span class="line">*mine = <span class="keyword">new</span> <span class="built_in">block</span>(ROW, COLUMN, BOOM_NUM);runtime = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);<span class="built_in">connect</span>(runtime, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_secondadd</span>()));<span class="built_in">connect</span>(runtime, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update</span>()));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_secondadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    mine-&gt;<span class="built_in">addtime</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//block.cppvoid block::addtime()&#123;    time_now++;&#125;//时间绘制部分与雷数量呈现部分相同</span></span><br></pre></td></tr></table></div></figure><h3 id="四-源码及素材来源"><a href="#四-源码及素材来源" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#四-源码及素材来源"></a> 四、源码及素材来源</h3><p>        <a target="_blank" rel="noopener" href="https://github.com/voyage-li/mine_sweep">源码</a><br>        <a target="_blank" rel="noopener" href="https://github.com/fengqian-wei/qt-mine-sweeping">扫雷图片素材来源</a></p></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://voyage-li.github.io/tags/GUI/">GUI</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://voyage-li.github.io/tags/Qt/">Qt</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://voyage-li.github.io/tags/DFS/">DFS</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/12/26/experience/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">建站经历</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/07/18/MC-RED/"><span class="paginator-prev__text">MC红石特效的原理</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar_basic"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%B8%BB%E4%BD%93%E5%87%BD%E6%95%B0%E7%9A%84c%E5%AE%9E%E7%8E%B0"><span class="toc-text">一、主体函数的C++实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.游戏的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">2.鼠标点击事件的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%B8%B8%E6%88%8F%E8%83%9C%E5%88%A9%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-text">3.游戏胜利的条件判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%8Ec%E8%BF%87%E6%B8%A1%E5%88%B0qt"><span class="toc-text">二、从C++过渡到Qt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%AA%97%E5%8F%A3%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-text">1.窗口的搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%89%AB%E9%9B%B7%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-text">2.扫雷界面的绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.鼠标点击事件的具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%82%B9%E5%87%BB%E6%95%B0%E5%AD%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.点击数字功能实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-text">5.程序的执行步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">三、额外功能的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%B8%8D%E5%90%8C%E9%9A%BE%E5%BA%A6%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-text">1.不同难度的选择和自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%89%A9%E4%BD%99%E9%9B%B7%E6%95%B0%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E5%91%88%E7%8E%B0"><span class="toc-text">2.剩余雷数量的计算以及呈现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%B8%B8%E6%88%8F%E6%97%B6%E9%97%B4%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%BB%98%E5%88%B6"><span class="toc-text">3.游戏时间记录与绘制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%BA%90%E7%A0%81%E5%8F%8A%E7%B4%A0%E6%9D%90%E6%9D%A5%E6%BA%90"><span class="toc-text">四、源码及素材来源</span></a></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><a href="/about"><img class="sidebar-ov-author__avatar_img" src="/images/icons/huan.svg" alt="avatar"></a></div><p class="sidebar-ov-author__text">每一天，每个季节都会过去， 然后就是新的开始</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/voyage-li/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="mailto:voyage@mail.ustc.edu.cn" target="_blank" rel="noopener" data-popover="邮件" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fa fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=923959605" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">10</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">15</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></div><div class="notice"><span class="notice_banner"><i class="fa fa-bell"></i></span><span class="notice_banner"> NOTICE</span><br><notice_text class="notice_text">反复刷新界面可能导致部分js失效</notice_text></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021~2022</span><span class="footer__devider"></span><span>voyage</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-arrow-up"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script><script src="/js/contribution.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.5" count="99" zindex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch(){var c=!0,t="search.json";t?/json$/i.test(t)&&(c=!1):t="search.xml",$.ajax({url:"/"+t,dataType:c?"xml":"json",async:!0,success:function(t){function e(){var t=o.val().toLowerCase().trim(),h=t.split(/[\s]+/),d=[];1<h.length&&h.push(t),0<t.length&&n.forEach(function(t){var e=!1,n=t.title&&t.title.trim()||"[ 文章无标题 ]",o=n&&n.toLowerCase(),i=t.content&&t.content.replace(/<[^>]+>/g,""),c=i&&i.toLowerCase(),s=t.url&&decodeURI(t.url).replace(/\/{2,}/g,"/"),a=[],r=[];h.forEach(function(t){function e(e,t,n,o){if(!e||!t)return[];var i,c=0,s=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(i=t.indexOf(e,c));){var r=!1;a.forEach(function(t){t.index===i&&t.word.length<e.length&&(t.word=e,r=!0)}),c=i+e.length,r||s.push({index:i,word:e,weight:o})}return s}a=a.concat(e(t,o,!1,f.title)),r=r.concat(e(t,c,!1,f.content))});var l=a.length,t=r.length;function u(n,t,e,o){if(n&&t&&t.length){var i="",c=e,o=o;return t.forEach(function(t){var e;t.index<c||(e=t.index+t.word.length,i+=n.slice(c,t.index),i+="<b>"+n.slice(t.index,e)+"</b>",c=e)}),i+=n.slice(c,o)}}(e=0<l||0<t?!0:e)&&([a,r].forEach(function(t){t.sort(function(t,e){return t.index-e.index})}),l={},t=a.length*f.title+r.length*f.content,e=u(n,a,0,n.length)||n,i=0<r.length?(n=r[0].index,u(i,r,20<n?n-20:0,n+180)):i.slice(0,200),l.title=e,l.content=i,l.url=s,l.weight=t,d.push(l))});var e="";d.length?(d.sort(function(t,e){return e.weight-t.weight}),e+="<ul>",d.forEach(function(t){e+='<li><a class="search-results-title" href="'+t.url+'">',e+=t.title,e+='</a><div class="search-results-content">',e+=t.content,e+="</div></li>"}),e+="</ul>"):e+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(e)}var n=c?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),f={title:100,content:1};o.on("input",e),o.on("keyup",function(t){t.keyCode===Stun.utils.codeToKeyCode("Enter")&&e()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(t){var e=window.open();e.opener=null,e.location=t}function extSearch(t){var e=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[t]+n+" site:"+e):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(t){t.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(t){t.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(t){document.querySelector(".search-btns-item--"+t).addEventListener("click",function(){extSearch(t)},!1)})</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-inner"],history:!0,scrollTo:0,scrollRestoration:!0,cacheBust:!1,debug:!1,currentUrlFullReload:!0,timeout:0});var e=null;document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:0,easing:"easeInOutCubic"});var a=20;$(".loading-bar").addClass("loading"),$(".loading-bar__progress").css("width",a+"%"),clearInterval(e),e=setInterval(function(){95<(a+=3)&&(a=95),$(".loading-bar__progress").css("width",a+"%")},500)},!1),window.addEventListener("pjax:complete",function(){clearInterval(e),$(".loading-bar__progress").css("width","100%"),$(".loading-bar").removeClass("loading"),setTimeout(function(){$(".loading-bar__progress").css("width","0")},400),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),Stun.utils.pjaxReloadHeader&&Stun.utils.pjaxReloadHeader(),Stun.utils.pjaxReloadScrollIcon&&Stun.utils.pjaxReloadScrollIcon(),Stun.utils.pjaxReloadLocalSearch&&Stun.utils.pjaxReloadLocalSearch()},!1)},!1)</script><div id="pjax-reload"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/quicklink@1.0.1/dist/quicklink.umd.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://voyage-li.github.io/2021/08/16/mine-sweep/"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="/js/Valine.min.js"></script><script data-pjax="">function loadValine(){var a=["nick","mail","link"],n="nick,mail".split(",").filter(function(n){return-1<a.indexOf(n)});new Valine({el:"#valine-container",appId:"QTR0840FHQ2lUL9IBbB4Jy6q-gzGzoHsz",appKey:"Nespb21fo2DLDIOnIg3hcFSC",notify:!0,verify:!0,enableQQ:!0,placeholder:"留下一句评论再走吧（请使用markdown语法）",avatar:"monsterid",meta:n,pageSize:"10",visitor:!0,recordIP:!0,lang:"zh-cn",path:window.location.pathname})}loadValine()</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>