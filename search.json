[{"title":"Oldstory","url":"/2022/11/13/oldStory/","content":"\n<!-- <p style=\"text-align:center;font-weight:bolder\">\n白苎新袍入嫩凉。春蚕食叶响回廊。禹门已准桃花浪，月殿先收桂子香。<br>\n鹏北海，凤朝阳。又携书剑路茫茫。明年此日青云去，却笑人间举子忙。</p> -->\n\n有时间再写\n\n<!--more-->\n"},{"title":"流水线cpu设计","url":"/2022/07/01/codlab/","content":"\n> **计算机组成原理 实验(llxx 老师)**\n\n虽然说`verilog`语言使用有诸多困难，但计算机组成原理课程的学习还是很有意思的，亲手(应该是)写一个 cpu 的感觉还是很有收获的，介绍介绍我的这个学期的实验\n\n<!-- ![](https://img1.imgtp.com/2023/03/15/xQJJZgc4.png) -->\n\n<!--more-->\n\n### Lab1 运算器及其应用\n\n- 完成 ALU 模块的逻辑设计和仿真\n- 查看 32 位 ALU 的 RTL 和综合电路图，以及综合电路资源和时间性能报告\n- 完成 6 位 ALU 的下载测试，并查看 RTL 电路图，以及实现电路资源和时间性能报告\n- 完成 FLS 的逻辑设计、仿真和下载测试\n  {% note info no-icon%}\n  本次实验主要是复习`verilog`的相关语法，为后续实验打下基础\n  {% endnote %}\n\n### Lab2 寄存器堆与存储器及其应用\n\n- 行为方式参数化描述寄存器堆，功能仿真\n- IP 例化分布式和块式 16 x 8 位单端口 RAM，功能仿真和对比\n- 设计 FIFO 队列电路的数据通路和控制器，结构化方式描述数据通路，Moore 型 FSM 描述控制器，功能仿真\n- FIFO 队列电路下载至 FPGA 中测试\n  {% note info no-icon%}\n  同样是对数电学习内容的复习，学会了设计不同的仿真函数，debug 的方法\n  {% endnote %}\n\n### Lab3 汇编程序设计\n\n- 熟悉 RISC-V 汇编指令的格式\n- 熟悉 CPU 仿真软件 Ripes，理解汇编指令执行的基本原理（数据通路和控制器的协调工作过程）\n- 熟悉汇编程序的基本结构，掌握简单汇编程序的设计\n- 掌握汇编仿真软件 RARS(RISC-V Assembler & Runtime Simulator)的使用方法，会用该软件进行汇编程序的仿真、调试以及生成 CPU 测试需要的指令和数据文件（COE）\n- 理解 CPU 调试模块 PDU 的使用方法\n  {% note info no-icon%}\n  较为简单的一次实验，主要是考察使用汇编解决问题的能力\n  {% endnote %}\n\n### Lab4 单周期 CPU 设计\n\n- 理解 CPU 的结构和工作原理\n- 掌握单周期 CPU 的设计和调试方法\n- 熟练掌握数据通路和控制器的设计和描述方法\n  {% note info no-icon%}\n  本次实验是`verilog`噩梦的开始，明明都按照设计写出来的东西，却不能达到预期的结果，但好在还是调试出来了\n  {% endnote %}\n\n### Lab5 流水线 CPU 设计\n\n- 理解流水线 CPU 的结构和工作原理\n- 掌握流水线 CPU 的设计和调试方法，特别是流水线中数据相关和控制相关的处理\n- 熟练掌握数据通路和控制器的设计和描述方法\n  {% note info no-icon%}\n  基本思路和前一次实验相同，就是把课内学习的知识投入实践，但流水线带来了诸多问题，处理各种冒险的过程还是很有意思的，尤其是最后处理完所有问题，上 fpga 运行成功以后，虽然花了十几个小时\n  {% endnote %}\n\n### Lab6 综合设计\n\n- 理解计算机硬件系统的组成结构和工作原理\n- 掌握软硬件综合系统的设计和调试方法\n  {% note info no-icon%}\n  实现了更多的指令，同时加入了 cache\n  {% endnote %}\n\n### 详细代码\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细的实验报告可以看:[链接](https://github.com/voyage-li/ustc_life/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86)\n","categories":["计算机组成原理"]},{"title":"迷你操作系统设计","url":"/2022/07/01/oslab/","content":"\n> **操作系统 实验(cxl 老师)**\n\n上了一个学期的操作系统，总算也是拼拼凑凑整了个玩具操作系统，写一篇文章来记录一下，本文就按照实验的顺序，介绍一下一个学期的成果吧\n\n<!-- ![](https://img1.imgtp.com/2023/03/15/QGdLqR1r.png) -->\n\n<!--more-->\n\n- 本文的实验均在`wsl2+Unbuntu`的环境下完成\n- 使用`qemu-system-i386`\n\n### 实验一：Start\n\n- 使用 multiboot 协议，借助 qemu 实现 VGA 的简单输出\n- `movx source, destination`\n  - `movl`: 32 位\n  - `movw`: 16 位\n  - `movb`: &nbsp;8&nbsp; 位\n- VGA 的输出：\n  - 使用`movl $0x2f4b2f4f, 0xB8000`的格式，其中，前串字符表示输出的字符，后字符串表示输出的地址\n  - 其中，每个字符需要 2 个字节，一个存放 ASCII 码，一个存放字符的显示颜色\n- 串口的输出：使用以下格式\n  ```asm\n  movb $0x46, %al /* 输出字母F */\n  movw $0x3F8, %dx\n  outb %al, %dx /* put char */\n  ```\n\n### 实验二：Multiboot2myMain\n\n- 在源代码的语言层面，完成从汇编语言到 C 语言的衔接\n- 在功能上，实现清屏、格式化输入输出，设备包括 VGA 和串口，接口符合要求\n  - 可以直接修改指针指向地址的值，以此实现修改 VGA 的输出，例如\n    ```c\n    void put_char2pos(unsigned char c, int color, unsigned short int pos)\n    {\n        unsigned short int data = 0;\n        data += color << 8;\n        data += c;\n        unsigned short int *p;\n        p = (unsigned short int *)(pos * 2 + VGA_BASE);\n        *p = data;\n        set_cursor_pos(pos + 1);\n    }\n    ```\n- 在软件层次和结构上，完成 multiboot_header、myOS 和 userApp 的划分，体现在文件目录组织和 Makefile 组织上\n\n### 实验三：shell&Interrupt&timer\n\n- 简单的 shell 程序，提供 cmd 和 help 命令，允许注册新的命令\n- 中断机制和中断控制器 i8259A 初始化\n- 时钟 i8253 和周期性时钟中断\n- VGA 输出的调整：\n  - 左下角：时钟中断之外的其他中断，一律输出“unknown interrupt”\n  - 右下角：从某个时间开始，大约每秒更新一次格式为：HH:MM:SS\n\n### 实验四：Memory Management\n\n- 内存检测，确定动态内存的范围\n- 提供动态分区管理机制 dPartition\n- 提供等大小固定分区管理机制 ePartition\n- 使用动态分区管理机制来管理所有动态内存\n- 提供 kmalloc/kfree 和 malloc/free 两套接口，分别提供给内核和用户\n\n### 实验五：TaskManager & FCFS\n\n- 任务管理器\n- 任务数据结构\n- 任务池：数据结构的静态 or 动态管理\n- 任务创建/销毁，任务启动和终止\n- 上下文切换\n- idle 任务、init 任务\n- 调度器 FCFS\n- 初始化完成后，转入多任务状态运行\n\n### 实验六：Scheduler\n\n- 调度算法，至少 2 种（不含 FCFS）\n- 任务管理器\n  - 任务数据结构\n  - 任务创建/销毁\n  - 调度器\n\n### 详细代码：请看\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细的实验报告可以看:[链接](https://github.com/voyage-li/ustc_life/tree/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/lab)\n","categories":["操作系统"]},{"title":"我的世界红石钢琴","url":"/2022/05/20/mc-piano/","content":"\n<video src='/images/mc/Trim.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'>\n</video>\n\n<!--more-->\n\n### 一、教学环境\n\n- 版本: 1.14.4(java 版本)\n\n### 二、前置知识\n\n- 基本的`mcfunction`相关知识\n- 基本的乐理\n\n### 三、搭建钢琴\n\n- 在游戏中搭建一个看起来和钢琴一样的东西(无需教学)\n- 可以使用`setblock`指令，快捷生成\n\n### 四、音乐资源\n\n- 可以使用本仓库中的材质包\n- 将材质包添加的游戏中\n- 使用`playsound`函数播放音乐资源\n  ```bash\n  playsound minecraft:piano.21 voice @p ~ ~ ~ 30\n  ```\n\n### 五、演奏的实现\n\n- 首先音乐需要按顺序播放，此处内容在[红石特效](https://voyage-li.github.io/2021/07/18/MC-RED/#%E5%85%AB-%E8%A1%A5%E5%85%85)文章已经讲述，可以直接点击链接跳转\n- 关于触发\n  - 直接在一个时间点播放对应的音乐固然能够达到红石钢琴的效果，但是这样明显达到不了本篇文章开头的效果\n  - 用下降的红石来触发播放音乐函数\n    ```bash\n    summon falling_block -293 45 63 {BlockState:{Name:\"minecraft:redstone_block\"},Time:30}\n    ```\n  - 将方块变成半砖再复原的形式模拟按键\n    ```bash\n    fill ~-1 ~3 ~ ~-10 ~3 ~ minecraft:quartz_slab\n    fill ~-7 ~3 ~-1 ~-10 ~3 ~-1 minecraft:quartz_stairs[facing=north]\n    fill ~3 ~1 ~ ~-6 ~1 ~ minecraft:quartz_block\n    fill ~-3 ~1 ~1 ~-6 ~1 ~1 minecraft:quartz_block\n    fill ~-3 ~1 ~-1 ~-6 ~1 ~-1 minecraft:quartz_block\n    ```\n- 在触发播放音乐效果的同时，可以带上一定的粒子效果\n- 然后就是枯燥的扒谱，根据时间，播放不同的音乐了\n\n### 六、效果展示\n\n![](/images/mc/last.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==看开头的视频==\n\n### 七、存档及代码\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[仓库地址](https://github.com/voyage-li/Minecraft_piano)\n","tags":["mcfunction"],"categories":["游戏","minecraft"]},{"title":"模拟手写字迹","url":"/2022/04/24/handwrite/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写操作系统作业的时候突发奇想，为什么要重复这种体力劳动呢，所以就有了这个东西，而当前网络上可以搜索到的模拟手写的程序都不适配 markdown 的语法，这对一个合格的 cs 学生来说是不可以忍受的，所以加上了适配 markdown 语法的功能。\n\n### 一、手写模拟部分\n\n- 使用`PIL`库，调用准备好的字库，进行书写\n- 由于是模拟人的输入，所以在输出时给每个字赋上随机的偏移，更贴近实际情况\n  ```python\n  # 设置字体格式大小等参数\n  PIL.ImageFont.truetype(font=None, size=10, index=0, encoding='', layout_engine=None)\n  # 创建可用于绘制给定图像的对象\n  PIL.ImageDraw.Draw(im, mode=None)\n  # 在给定位置绘制字符串\n  PIL.ImageDraw.ImageDraw.text(xy, text, fill=None, font=None, anchor=None, spacing=4,    align=\"left\", direction=None, features=None, language=None, stroke_width=0,    stroke_fill=None)\n  ```\n\n<!--more-->\n\n### 二、markdown 的相关处理\n\n- 使用正则表达式`re`库\n- 分析需求，程序应该只需要处理标题，列表等功能，而对于超链接，插入图片，字体加粗删除斜体等功能，不是这个程序需要实现的功能\n- 对于标题，先使用正则表达式检测，然后控制输出字体的大小\n- 使用`re.sub()`函数，将源文件中的所有字体格式删除\n- 对于列表功能，本程序使用较为笨拙的方法，在正则表达式匹配到列表相关内容时，在文本中空出相应的空格，并用特殊字符标记，以便最后输出\n  ```python\n  def translate(txt):\n      f = open(txt, 'r', encoding='utf-8')\n      string = f.read()\n      f.close()\n      if '.txt' in txt:\n          return string\n      # 直接去掉所有有标题的内容\n      string = re.sub(r'(#{1,6}) (.+)', tittle, string)\n      # 有序无序在一起会很丑陋\n      string = re.sub(r'[.\\n][\\-\\+\\*] (.+)', lambda x: '\\n'+' ● ' + x.group(1), string)\n      string = re.sub(r'[.\\n][\\ ]{4}[\\-\\+\\*] (.+)', lambda x: '\\n    '+' ○ ' + x.group    (1), string)\n      string = re.sub(r'[.\\n][\\ ]{8}[\\-\\+\\*] (.+)', lambda x: '\\n        '+' ■ ' + x. group(1), string)\n      string = re.sub(r'[.\\n](\\d.) (.+)', lambda x: '\\n '+x.group(1)+x.group(2),  string)\n      string = re.sub(r'[.\\n][\\ ]{4}(\\d). (.+)', list_sub_2, string)\n      string = re.sub(r'[.\\n][\\ ]{8}(\\d). (.+)', list_sub_3, string)\n      string = re.sub(r'[.\\n][\\ ]{12}(\\d). (.+)', list_sub_4, string)\n      # 去掉链接\n      string = re.sub(r'\\[(.+)\\]\\((.+)\\)', lambda x: x.group(1)+'('+x.group(2)+')',   string)\n      # 去掉text内容\n      for iter in text_re:\n          string = re.sub(iter, lambda x: x.group(1), string)\n\n      return string\n  ```\n\n### 三、图形化功能\n\n- 考虑到实际使用的体验，程序应该拥有图形化界面，便于操作\n- 使用`pyqt`直接拖动控件设计图形化界面，将最后的`mainwindows.ui`文件导出，使用`pyuic5`获得`mainwindow.py`\n- 最后将 ui 界面的相关接口和主程序代码链接在一起\n\n### 四、源代码\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[戳这里](https://github.com/voyage-li/HandWrite)\n","tags":["pyqt","正则表达式"],"categories":["python"]},{"title":"git使用记录","url":"/2022/03/23/git/","content":"\n记录 git 的使用过程中遇到的问题\n\n### 合并仓库\n\n记录合并 git 仓库的方法，主要就是根据网上查找的\n\n##### 目录情况:\n\n```bash\n/temp/\n    ├── A\n    └── B\n```\n\n<!--more-->\n\n##### 具体步骤\n\n- 将 B 合并到 A\n\n  ```bash\n  cd temp/A\n  git remote add other ../B/\n  git fetch other\n  git checkout -b B other/main\n  git checkout main\n  git merge B --allow-unrelated-histories\n  ```\n\n- 处理冲突\n\n  直接打开 vscode，点一点，或者 vim 删除不需要的部分，之后(记得 git add)\n\n  ```bash\n  git commit -m \"merge A&B\"\n  ```\n\n##### 善后\n\n```bash\ngit remote -v\ngit remote remove other\ngit branch\ngit branch -D B\n```\n","tags":["git"]},{"title":"wsl2使用windows代理","url":"/2022/02/21/clash/","content":"\n使用 wsl2 克隆的过程中经常因为奇慢无比的速度而抓狂，查阅了相关资料之后，找出对自己有效的 wsl2 走 windows 代理的方法\n![git.jpg](https://s2.loli.net/2022/02/27/T39PQYMHkuD8m6F.jpg)\n\n<!--more-->\n\n### 一、前置\n\n这里使用的是 clash for windows，注意需要打开允许局域网，打开的时候可能发现，鼠标悬停在开关上时，能看到 wsl 的 ip\n\n### 二、具体实施\n\n在 wsl 终端输入:\n\n```bash\ncat /etc/resolv.conf\n```\n\n可以查看 hostip:\n\n```bash\n# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:\n# [network]\n# generateResolvConf = false\nnameserver 172.24.32.1\n```\n\n此后输入\n\n```bash\nexport https_proxy=\"http://${hostip}:7890\"\nexport http_proxy=\"http://${hostip}:7890\"\nexport all_proxy=\"socks5://${hostip}:7890\"\n#hostip为刚才查询的ip，后面的端口号 clash默认为 7890\n```\n\n### 三、写成脚本\n\n```sh\n#config.fish\nset host_ip (cat /etc/resolv.conf |grep \"nameserver\" |cut -f 2 -d \" \")\nalias setproxy \"export all_proxy=http://$host_ip:7890 && export http_proxy=http://$host_ip:7890 && export https_proxy=http://$host_ip:7890\"\nalias unset \"set --erase\" # fish-shell使用unset需要 set --erase\nalias unsetproxy \"unset all_proxy && unset http_proxy && unset https_proxy\"\n```\n\n将上述内容写入 fish-shell 配置文件，使用 setproxy 打开代理，unsetproxy 关闭代理\n\n### 四、检测成果\n\n测试的方法有很多，比如:\n\n```bash\nwget youtube.com\n```\n\n或者\n\n```bash\nw3m www.google.com\n```\n","tags":["wsl2"],"categories":["shell"]},{"title":"fish shell使用心得","url":"/2022/01/25/fish-shell/","content":"\n阴差阳错的，就用上了 fish，然后就不想换别的了，但是 fish 不兼容很多的 bash 脚本，与网上主流教程有一些区别，在这里记录我使用 fish 踩的坑\n\n<!-- ![fish.png](https://s2.loli.net/2022/01/25/y59mJL4gXH3EhkC.png) -->\n\n### 一、fish shell 简介\n\n- 全名: [the friendly interactive shell](https://fishshell.com/)\n- ubuntu 下安装(其它同理)\n\n```bash\nsudo apt install fish\n```\n\n<!--more-->\n\n### 二、基本配置\n\n#### 1. 颜色主题\n\n```bash\nfish_config\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;进入网页端设置界面，设置自己喜欢的颜色主题\n&nbsp;&nbsp;&nbsp;&nbsp;我的配置: [fish_prompt.fish](https://github.com/voyage-li/my_study/blob/master/Missing-Semester/fish_prompt.fish)\n\n#### 2. 欢迎页面\n\n```sh\n# ~/.config/fish/functions/fish_greeting.fish\nfunction fish_greeting\n    echo \"欢迎文本\"\n    # 可选项:\n    # date （当前时间信息）\n    # neofetch (显示运行状态，需要安装 neofetch ，换成 screenfetch 同理)\nend\n```\n\n### 三、函数\n\n#### 1. 基本格式\n\n仿照前面欢迎界面的格式\n\n```sh\nfunction hello\n    echo \"hello fish shell\"\nend\n```\n\n{% note info no-icon %}\n当你直接运行 bash 脚本时，fish 会提示不兼容的地方以及修改方法\n{% endnote %}\n\n#### 2. 命令行参数\n\n使用`$argv[num]`的形式获得命令行参数，`$status`获取返回值，`count`输出参数数量，示例函数如下\n\n```sh\nfunction test_argv\n    echo $argv\n    echo $argv[1] $argv[2]\n    echo $argv[3]\n    echo $status\n    count $argv\nend\n```\n\n调用:\n\n```bash\ntest_argv 测试 一下 命令行\n```\n\n输出:\n\n```bash\n测试 一下 命令行\n测试 一下\n命令行\n0\n3\n```\n\n#### 3. 语法\n\n##### a. if 语句\n\n```sh\nfunction test_if\n    if [ (count $argv) -eq 0 ]\n        echo \"false\"\n    else if [ \"$argv[1]\" -eq \"$argv[2]\" ]\n        echo $argv[1] \"==\" $argv[2]\n    else\n        echo $argv[1] \"!=\" $argv[2]\n    end\nend\n```\n\n```bash\n# 输入\ntest_if 2 3\n# 输出\n2 != 3\n```\n\n##### b. switch 语句\n\n```sh\nfunction test_switch\n    for string in $argv\n        switch $string\n            case \"switch\"\n                echo \"this is switch\"\n            case \"if\"\n                echo \"this is if\"\n            case \"while\"\n                echo \"this is while\"\n            case '*'\n                echo \"none\"\n        end\n    end\nend\n```\n\n```bash\n# 输入\ntest_switch \"if\" \"while\" \"switch\" \"dsads\"\n# 输出\nthis is if\nthis is while\nthis is switch\nnone\n```\n\n##### c. while 语句\n\n```sh\nfunction test_while\n    while true\n        echo \"fish shell\"\n    end\nend\n```\n\n---\n\n<!-- ==太晚了睡觉了，有时间再写== -->\n\n### 四、一些问题\n\n#### 1.兼容 bash 脚本\n\n正常写命令行脚本，例如`test.sh`，赋予其运行权限后，用以下指令运行\n\n```bash\nbash -c ./test.sh\n```\n\n如果是经常需要使用的脚本，可以将以下内容写入`config.fish`\n\n```bash\nalias test \"bash -c ./test.sh\" #应该修改为全局路径\n```\n\n`test`即可运行该脚本\n\n#### 2.安装 anaconda\n\n##### a. 安装脚本\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[https://mirrors.ustc.edu.cn/anaconda/archive/](https://mirrors.ustc.edu.cn/anaconda/archive/)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~没错，这个是科大的镜像站，指向的却是北外的源，这何尝不是一种 ntr~~\n\n##### b. 具体安装过程\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接执行该脚本(chmod 赋予权限)，然后会让你看一些条例啊，确定安装位置啥的，就 yes/no 选择一下，注意最后面推荐你写入环境变量，选择 no，以及是否安装 vscode，选择 no\n\n##### c. 兼容性调整\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据这个[anaconda/fish-shell](https://anaconda.org/mdraw/fish-shell)，在 bash 内运行以下命令\n\n```bash\nconda install -c mdraw fish-shell #可能需要先添加环境变量（见下方）\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后打开 config.fish 配置文件，加入两行\n\n```sh\nset -x PATH /home/your_name/anaconda3/bin $PATH       #根据安装路径调整\nsource /home/your_name/anaconda3/etc/fish/conf.d/conda.fish\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重启一下终端，大功告成\n\n---\n\n{% note info no-icon%}\n~~**二逼青年用 bash，普通青年用 zsh，文艺青年用 fish**~~\n{% endnote %}\n","tags":["fish","anaconda"],"categories":["shell"]},{"title":"Dijkstra实现导航软件","url":"/2022/01/03/navigation/","content":"> **数据结构 大作业二**\n\n\n### 一、实验要求\n\n&nbsp;&nbsp;&nbsp;&nbsp;要求在所给的数据集上建立图结构（邻接矩阵或者邻接表），并在建立的图结构上自行实现Dijkstra算 法求解任\t意两点之间的最短路径。\n\n- 输入输出要求：\n    Input : src(源点)   Dst(目标点)\n    Output :\n&nbsp;&nbsp;&nbsp;&nbsp;(1) 最短路径的长度： distance\n&nbsp;&nbsp;&nbsp;&nbsp;(2) Src到Dsr的一条最短路径，例如：Src->p1->p2->p3->...->Dst(逆序输出也对)\n\n### 二、实验目的，\n&nbsp;&nbsp;&nbsp;&nbsp;熟悉并掌握图的建立算法和Dijkstra求图上最短路径算法，了解Dijkstra算法的改进方法，掌握时间复杂度的分析方法并且去分析对比验证不同时间复杂度的Dijkstra算法的时间开销，了解稀疏的图结构的压缩存储方法。\n<!--more-->\n### 三、程序能实现的功能\n\n- 对数据文件进行二进制处理，同时少量压缩二进制文件\n- 根据数据文件建立图结构(邻接表)\n- 使用朴素法，二叉堆，配对堆，fibonacii堆搜索最短路径，对于大数据测试样例，搜索时间能够sub10\n\n### 四、设计思路\n\n- 预处理\n    - 将原数据文件转换为二进制形式\n    - 建立图的邻接表，将图按顺序输出，同一个出发点的边只记录以此源点，用度数来标记下一个源点\n- dijkstra\n    - 建立`visited`与`distance`数组\n    - 初始`visited`数组置0，`distance`数组置最大(由于`memset()`的限制，稍小于`INT_MAX`)\n    - 将源点距离设为0，访问设为1，遍历所有与源点相连的边，记录距离进入distance数组\n    - 从distance数组中找出distance最短的点，记为$u$，遍历所有与$u$相连的边，相连的点记为$v_1,v_2,...,v_n$，如果$visited[v_i]==0\\& distance[v_i]>distance[u]+weight_{u->v}$，更新$distance[v_i]$的值\n    - 重复上述操作，知道$visited[Dst]==1$或者整个图已搜索完毕，仍然没有找到路径\n    - 逆序输出最短路径\n\n### 五、项目结构\n\n```bash\n─ navigation\n  ├── binary\n  │   └── pre.cpp\n  ├── CMakeLists.txt\n  ├── include\n  │   ├── dijkstra.h\n  │   ├── fibheap.h\n  │   ├── graph.h\n  │   ├── Heap.h\n  │   └── pair_heap.h\n  └── src\n      ├── dijkstra.cpp\n      ├── fibheap.cpp\n      ├── graph.cpp\n      ├── Heap.cpp\n      ├── main.cpp\n      └── pair_heap.cpp\n```\n\n### 六、关键内容实现\n\n#### 1. dijkstra(堆优化)\n```c++\nint *visited = new int[100000000];\nmemset(visited, 0, sizeof(int) * 100000000);\nint *dis = new int[100000000];\nmemset(dis, 127, sizeof(int) * 100000000);\nint *pre = new int[100000000];\nmemset(pre, -1, sizeof(int) * 100000000);\nHeap<struct node> q;\ndis[x] = 0;\nq.push(node(x, dis[x]));\nwhile (!q.empty())\n{\n    struct node now = q.top();\n    q.pop();\n    if (visited[now.begin] == 1)\n        continue;\n    visited[now.begin] = 1;\n    if (now.begin == y)\n        break;\n    struct ArcNode *p = G.data[now.begin]->firstarc;\n    while (p != nullptr)\n    {\n        if (visited[p->adjvex] != 1 && dis[p->adjvex] > dis[now.begin] + p->weight)\n        {\n            dis[p->adjvex] = dis[now.begin] + p->weight;\n            q.push(node(p->adjvex, dis[p->adjvex]));\n            pre[p->adjvex] = now.begin;\n        }\n        p = p->nextarc;\n    }\n}\nif (visited[y] != 1)\n{\n    std::cout << \"不能到达!\" << std::endl;\n    delete[] visited;\n    delete[] dis;\n    delete[] pre;\n    return;\n}\nint road = y;\nwhile (road != -1)\n{\n    printf(\"\\033[0;30;47m%d\\033[0m \", road);\n    road = pre[road];\n    if (road != -1)\n        std::cout << \"<- \";\n    else\n        printf(\"\\n\");\n}\nstd::cout << \"\\nOutput:\\n\"\n          << dis[y] << std::endl;\n\ndelete[] visited;\ndelete[] dis;\ndelete[] pre;\n```\n\n#### 2. 二叉堆\n- 存储结构\n    ```c++\n    template <class T>\n    class Heap\n    {\n    private:\n        std::vector<T> data;\n        int length;\n\n    public:\n        Heap();\n        ~Heap();\n        inline void swim(int k);      //上浮\n        inline void sink(int k);      //下沉\n        inline void push(T e);        //入堆\n        inline void pop();            //出堆\n        inline T top();               //返回堆顶元素\n        inline bool empty();          //判断是否为空\n        inline int size();            //返回大小\n        inline void swap(T &a, T &b); //交换元素\n    };\n    ```\n\n- 上浮\n    ```c++\n    while (k > 1 && data[k] > data[k / 2])\n    {\n        swap(data[k], data[k / 2]);\n        k /= 2;\n    }\n    ```\n\n- 下沉\n    ```c++\n    while (k * 2 <= length)\n    {\n        int j = 2 * k;\n        if (j < length && (data[j] < data[j + 1])) //找到左右子树中更小的\n            j++;\n        if (data[k] > data[j])\n            break;\n        swap(data[k], data[j]);\n        k = j;\n    }\n    ```\n\n#### 3. 配对堆\n- 存储结构\n    ```c++\n    template <class T>\n    class pair_node\n    {\n    public:\n        T val;\n        int left;\n        int right;\n        pair_node()\n        {\n            left = 0;\n            right = 0;\n        }\n        pair_node(T e)\n        {\n            val = e;\n            left = 0;\n            right = 0;\n        }\n    };\n    template <class T>\n    class pair_heap\n    {\n    private:\n        std::vector<pair_node<T>> data;\n        int length; //已经到达的vector地址\n        int _size;  //实际存储的大小\n        inline void merge(int x, int y);\n        inline int merges(int x, int y);\n        int root;\n        inline int pop_();\n\n    public:\n        pair_heap();\n        ~pair_heap();\n        inline void push(T e);\n        inline void pop();\n        inline void _pop();\n        inline T top();\n        inline bool empty();\n        inline int size();\n    };\n    ```\n\n- merge\n    ```c++\n    void merge(int x, int y)\n    {\n        if (!x || !y)\n            root = x + y;\n        else if (x == y)\n            root = x;\n        else\n        {\n            if (data[x].val < data[y].val)\n            {\n                int temp = x;\n                x = y;\n                y = temp;\n            }\n            data[y].right = data[x].left;\n            data[x].left = y;\n            data[x].right = 0;\n            root = x;\n        }\n    }\n    ```\n- pop即反复merge根节点的孩子节点\n\n#### 4. Fibonacii堆\n- 存储结构\n    ```c++\n    template <typename T>\n    struct fib_node\n    {\n        struct fib_node<T> *parent;\n        struct fib_node<T> *child;\n        struct fib_node<T> *left;\n        struct fib_node<T> *right;\n        T key;\n        int degree;\n        fib_node() : parent(nullptr), child(nullptr), left(this), right(this), degree(0) {}\n    };\n    template <class T>\n    class FibHeap\n    {\n    private:\n        int keyNum;\n        int maxDegree;\n        struct fib_node<T> *min;\n        struct fib_node<T> **cons;\n        void removeNode(struct fib_node<T> *node);\n        void addNode(struct fib_node<T> *node, struct fib_node<T> *root);\n        void consolidate();\n        struct fib_node<T> *extractMin();\n        void makeCons();\n        void link(struct fib_node<T> *node, struct fib_node<T> *root);\n        void theEnd(struct fib_node<T> *node);\n\n    public:\n        FibHeap();\n        ~FibHeap();\n        void push(T e);\n        void pop();\n        bool empty();\n        int size();\n        T top();\n    };\n    ```\n- 具体操作见源码\n\n### 七、测试程序的正确性及性能\n\n> 引入pbds库中各种最小堆进行比较\n\n- 对于小数据测试样例\n\n    ![test_small.png](https://s2.loli.net/2022/01/14/dS3fkzgEXIT8sci.png)\n\n    可以看到，对于小数据测试样例，除了朴素法时间过长以外，手写的堆以及pbds库中的堆都可以在1s之内完成搜索，由于电脑性能不稳定，时间的差距可以忽略\n    \n- 对于两组大数据测试样例\n\n    - 3141592->2718281\n\n    ![test_big_1.png](https://s2.loli.net/2022/01/14/lcvQpPWKeRTuai5.png)\n\n    - 1000000->2000000\n\n    ![test_big_2.png](https://s2.loli.net/2022/01/14/Cwic3ODkSP681Fr.png)\n\n    - 对于大数据测试，朴素法在一个小时内都无法搜索出答案\n    - 所有堆优化的算法都可以在25s之内完成搜索\n\n    - 手动实现的二叉堆拥有最好的性能，较之系统的优先队列，也有更好的表现\n    - 递归实现pop的配对堆与系统配对堆性能相仿，队列实现pop则稍有差距(如果在编译时开启O2优化，队列的性能会强于递归，但是O2优化不够稳定)\n    - Fibonacci堆较之pbds库有着不小的差距\n\n- 一些思考\n\n    配对堆和Fibonacci堆在理论上的时间复杂度都应该优于二叉堆，但是手写的二叉堆反而性能最佳，pbds库配对堆和Fibonacci堆较二叉堆也没有极其突出的表现，我认为原因可能有：\n\n    - 测试数据点特殊，具有偶然性\n    - 在入堆的操作上，二叉堆是$O(log(n))$的，配对堆和Fibonacci堆是$O(1)$的，此时二叉堆的性能较差，但由于数据特殊性，在每次入堆时，所需要经历的上浮操作较少\n    - 在出堆的操作上，三种堆结构均是$O(log(n))$的，但是配对堆和Fiboncci堆是均摊复杂度，单次操作极限情况下:$\\lim_{n\\to+\\infty}\\frac{n}{2}+\\frac{n}{4}+\\frac{n}{8}+...=n$，由于出堆几乎不是连续的，虽然上次出堆使根节点的孩子节点变成了原来的一半，由于不能立刻弹出，经历了多次入堆操作后，出堆的复杂度仍然是较高的，浪费了过多的时间\n\n### 八、编译过程\n\n- 编译环境\n    - Ubuntu-20.04 ( wsl2 )\n    - gcc 9.3.0\n    - cmake version 3.16.3\n\n- CMakeLists.txt (注意修改Debug模式和Release模式)\n\n    ```cmake\n    cmake_minimum_required(VERSION 3.5)\n    \n    project(navigation)\n    \n    set (CMAKE_CXX_STANDARD 17)\n    \n    set(SOURCES\n        src/main.cpp\n        src/dijkstra.cpp\n        src/graph.cpp\n        src/Heap.cpp\n        src/pair_heap.cpp\n        src/fibheap.cpp)\n    \n    add_executable(navigation ${SOURCES})\n    \n    SET(CMAKE_BUILD_TYPE \"Release\")\n    # SET(CMAKE_BUILD_TYPE \"Debug\")\n    \n    target_include_directories(navigation\n    PRIVATE\n        ${CMAKE_CURRENT_SOURCE_DIR}/include)\n    ```\n    \n- 编译操作(Release版本为例，首先进入项目目录)\n\n    ```bash\n    mkdir Release\n    cd Release\n    cmake ..\n    make\n    ulimit -s unlimited # linux下打开内存限制\n    ./navigation\n    # 运行程序\n    ```\n\n### 九、源码\n&nbsp;&nbsp;&nbsp;&nbsp;[戳这里](https://github.com/voyage-li/navigation)\n","tags":["dijkstra","堆"],"categories":["程序设计","C++","数据结构"]},{"title":"Huffman压缩","url":"/2022/01/02/huffman/","content":"> **数据结构 大作业一**\n\n### 一、问题描述\n\n在合适的情况下，利⽤ Huffman 编码对⽂件进⾏压缩可以减少其占⽤空间，同时在需要使⽤到⽂件的 时候也可以根据压缩⽂件中所提供的信息来将其还原为原⽂件。本次实验中，我们将实现⼀个基于 Huffman 编码的⽂件压缩/解压缩⼯具。\n\n### 二、基本要求\n\n基于 Huffman 编码实现⼀个压缩器和解压缩器（其中 Huffman 编码以字节作为统计和编码的基本符号 单元），使其可以对任意的⽂件进⾏压缩和解压缩操作。针对编译⽣成的程序，要求压缩和解压缩部分 可以分别独⽴运⾏。具体要求为：\n\n- 每次运⾏程序时，⽤⼾可以指定**只压缩/只解压**缩指定路径的⽂件。实现的时候不限制与⽤⼾的交 互⽅式，可供参考的⽅式包括但不限于\n  - 根据命令⾏参数指定功能（压缩/解压缩）和输⼊/输出⽂件路径\n  - GUI 界⾯\n  - 运⾏程序后由⽤⼾交互输⼊指定功能和路径\n<!--more-->\n- **【CAUTION!】不被允许的交互⽅式**： 通过修改源代码指定功能和⽂件路径\n\n- 压缩时不需要指定解压⽂件的⽬标路径，解压缩时不需要指定压缩前原⽂件的路径，压缩后的⽂件 可以换到另⼀个位置再做解压缩\n\n### 三、程序能实现的功能\n\n1. 压缩指定路径的任意格式的文件\n2. 解压指定路径的文件(无损)\n3. 可以选择压缩的基本单元(0.5Byte ~ 4Byte)\n4. 可以选择使用多元 Huffman 数进行压缩 (2~16)\n5. 3，4 项同时使用\n\n### 四、实验思路\n\n1. 压缩\n   - 第一遍扫描文件，根据用户选择的压缩基本单元，统计每一种基本单元出现的频次\n   - 以出现的频次作为权重，根据用户选择构建 Huffman 树，若用户选择多元压缩，则首先补全节点数，其次使用优先队列，每次弹出最小的元素，构造 Huffman 树\n   - 根据构造出的 Huffman 树，求得 Huffman 编码 (压缩单元较小时，使用指针 new 内存的形式加速，压缩单元较大时，使用 map 来控制内存的使用)\n   - 首先输出被压缩文件的类型，压缩时使用的基本单元大小，Huffman 树种类，再输出每一个基本单元出现的频次\n   - 再次扫描文件，每当获取一个基本单元大小的字节，二进制输出它的 Huffman 编码 (每八位以一个字符的形式输出)\n2. 解压\n   - 首先获得压缩文件头部的相关信息，以及各个基本单元出现的频次\n   - 用和压缩时完全相同的方式构造出 Huffman 树，获得 Huffman 编码\n   - 扫描剩下的文件内容，根据二进制编码，转化为原来的基本单元输出\n\n### 五、项目结构\n\n```bash\n─ huffman-compress\n  ├── CMakeLists.txt\n  ├── include\n  │   ├── big.h\n  │   ├── huffman.h\n  │   ├── small.h\n  │   └── tempwindow.h\n  └── src\n      ├── big.cpp\n      ├── huffman.cpp\n      ├── main.cpp\n      ├── small.cpp\n      └── tempwindow.cpp\n```\n\n### 六、关键内容实现\n#### 1. huffman树的建立\n```c++\n//初始化 huffman树\nlong long int fre = map.size();\nHT = new HTNode[2 * fre];\nfor (long long int i = 0; i < 2 * fre; i++)\n{\n    HT[i].num = i;\n    HT[i].key = 0;\n    HT[i].weight = 0;\n    for (int j = 0; j < tree_n; j++)\n        HT[i].child[j] = 0;\n    HT[i].parent = 0;\n}\nint index = 1;\nHT[0].weight = INT_MAX;\nfor (auto iter : map)\n{\n    HT[index].key = iter.first;\n    HT[index].weight = iter.second;\n    index++;\n}\n//使用优先队列构造huffman树\nstd::priority_queue<HTNode> ans;\nfor (int i = 1; i <= fre; i++)\n    ans.push(HT[i]);\nif (tree_n != 2)\n{\n    int blank;\n    if (fre % (tree_n - 1) == 0)\n        blank = 1;\n    else\n        blank = tree_n - fre % (tree_n - 1);\n    if (blank != tree_n - 1)\n    {\n        HuffmanTree Tree_blank = new HTNode;\n        Tree_blank->key = 0;\n        Tree_blank->parent = 0;\n        Tree_blank->weight = 0;\n        for (int j = 0; j < tree_n; j++)\n            Tree_blank->child[j] = 0;\n        for (int i = 0; i < blank; i++)\n        {\n            Tree_blank->num = fre + i + 1;\n            ans.push(*Tree_blank);\n        }\n    }\n}\n//要从加了0之后开始计算 即修正fre\nfor (long long int now = fre + 1; now < 2 * fre; now++)\n{\n    int now_weight = 0;\n    for (int i = 0; i < tree_n; i++)\n    {\n        HTNode temp_Node = ans.top();\n        HT[temp_Node.num].parent = now;\n        HT[now].child[i] = temp_Node.num;\n        now_weight += temp_Node.weight;\n        ans.pop();\n    }\n    HT[now].weight = now_weight;\n    if (ans.empty())\n        break;\n    ans.push(HT[now]);\n}\n```\n\n#### 2. 获取huffman编码\n```c++\nchar *cd = new char[fre];\ncd[fre - 1] = '\\0';\nfor (long long int i = 1; i <= fre; i++)\n{\n    long long int start = fre - 1;\n    long long int j, p;\n    for (j = i, p = HT[i].parent; p != 0; j = p, p = HT[p].parent)\n    {\n        int index = 0;\n        while (HT[p].child[index] != j)\n            index++;\n        int wei = judge(tree_n);\n        for (int i = 0; i <= wei - 1; i++)\n            cd[--start] = ((index >> i) & 1) + '0';\n    }\n    HC[HT[i].key] = (char *)malloc((fre - start) * sizeof(char));\n    strcpy(HC[HT[i].key], &cd[start]);\n}\n```\n\n#### 3. 压缩\n```c++\nwhile (infile.get(c))\n{\n    now_byte++;\n    char_now = 0;\n    while (char_now < 8)\n    {\n        while (char_now < 8)\n        {\n            tt_key += (((int)c >> (7 - char_now)) & 1) << (every - 1 - now_bit);\n            char_now++;\n            now_bit++;\n            if (now_bit == every)\n                break;\n        }\n        if (now_bit == every)\n        {\n            i = 0;\n            while (HC[tt_key][i] != '\\0')\n            {\n                tt += (HC[tt_key][i] - '0') << (7 - num);\n                i++;\n                num++;\n                if (num == 8)\n                {\n                    outfile.put((char)tt);\n                    num = 0;\n                    tt = 0;\n                }\n            }\n            now_bit = 0;\n            tt_key = 0;\n        }\n    }\n}\n//输出最后一个可能没有到达一个单位的字符\nif (now_bit != every && now_bit != 0)\n{\n    i = 0;\n    while (HC[tt_key][i] != '\\0')\n    {\n        tt += (HC[tt_key][i] - '0') << (7 - num);\n        i++;\n        num++;\n        if (num == 8)\n        {\n            outfile.put((char)tt);\n            num = 0;\n            tt = 0;\n        }\n    }\n}\n//输出可能没有到达8bit的最后一个字符\nif (num != 0)\n    outfile.put((char)tt);\n```\n\n#### 4. 解压\n```c++\nwhile (1)\n{\n    infile.get(c);\n    int tt = c;\n    index = 0;\n    for (int i = 7; i >= 0; i--)\n        ans[index++] = ((tt >> i) & 1) + '0';\n    index = 0;\n    while (1)\n    {\n        switch_child += (ans[index] - '0') << (wei - 1 - wei_now);\n        wei_now++;\n        if (wei == wei_now)\n        {\n            wei_now = 0;\n            now = HT[now].child[switch_child];\n            switch_child = 0;\n        }\n        index++;\n        if (HT[now].child[0] == 0)\n        {\n            //获取对应权值对应的 bit位\n            int int_to_char = HT[now].key;\n            char ans_[every + 1];\n            ans_[every] = '\\0';\n            for (int j = 0; j < every; j++)\n                ans_[j] = ((int_to_char >> (every - 1 - j)) & 1) + '0';\n            int j = 0;\n            while (ans_[j] != '\\0')\n            {\n                now_bit++;\n                out_tmp += (ans_[j] - '0') << (8 - now_bit);\n                if (now_bit == 8)\n                {\n                    char_size--;\n                    outfile.put(out_tmp);\n                    now_byte++;\n                    tmp_struct = {now_byte, size};\n                    out_tmp = 0;\n                    now_bit = 0;\n                }\n                j++;\n                if (char_size == 0)\n                    break;\n            }\n            now = root_loc;\n        }\n        if (index == 8 || char_size == 0)\n            break;\n    }\n    if (char_size == 0)\n        break;\n}\n```\n\n### 七、编译过程\n\n- 编译环境\n\n  - Ubuntu-20.04 ( wsl2 )\n  - gcc 9.3.0\n  - cmake version 3.16.3\n\n- CMakeLists.txt (注意修改 Debug 模式和 Release 模式)\n\n  ```cmake\n  cmake_minimum_required(VERSION 3.5)\n\n  project(yasuo)\n\n  set (CMAKE_CXX_STANDARD 17)\n\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pthread\" )\n\n  set(SOURCES\n      src/main.cpp\n      src/big.cpp\n      src/small.cpp\n      src/tempwindow.cpp\n      src/huffman.cpp)\n\n  add_definitions(-w)# system忽略了返回值，消除编译警告\n\n  add_executable(yasuo ${SOURCES})\n\n  SET(CMAKE_BUILD_TYPE \"Release\")\n\n  target_include_directories(yasuo\n  PRIVATE\n      ${CMAKE_CURRENT_SOURCE_DIR}/include)\n  ```\n\n- 编译操作(Release 版本为例，首先进入项目目录)\n\n  ```bash\n  mkdir Release\n  cd Release\n  cmake ..\n  make\n  ./yasuo\n  # 运行程序\n  ```\n\n### 八、运行效果\n\n- 使用 1.5Byte 为基本单元，三叉 Huffman 树压缩 png 文件，源文件 258kb，压缩后 182kb，解压后 258kb，效果较为明显，同时文件解压后无任何变化\n\n  ![eg.png](https://s2.loli.net/2022/01/14/Xi1LHKtRrx5qUe8.png)\n\n- 性能测试\n\n  使用该程序压缩大小 1.3G 的 txt 文档\n\n  - 压缩用时：130.917s\n\n  - 解压用时：113.172s\n\n  - 压缩效率：$46\\%$\n\n    ![test_.png](https://s2.loli.net/2022/01/14/Ei7wSqeNHyOgxAD.png)\n\n### 九、关于 Huffman 压缩的探索\n\n- 压缩一包含中英文及数字的 txt 文档，压缩效果如下(压缩率=$\\frac{\\text{压缩文件大小}}{\\text{原始文件}}$)\n  ![table.png](https://s2.loli.net/2022/01/14/tBP1oyzaV7hlkNe.png)\n\n- 利用上述数据作图 (mathematica 作图有一定偏差)\n\n  ![pc.png](https://s2.loli.net/2022/01/14/Q3F5Vp9dJu8ThOM.png)\n\n- 根据上述实验数据可以看出:\n  - 压缩基本单元为 0.5Byte 时，基本没有压缩效果\n  - 随着压缩基本单元的增大，压缩效果总体上呈现上升趋势\n  - 在压缩的基本单元从 3.0Byte 变为 3.5Byte 时，压缩效果均有小幅下降\n  - 当选用$2^n$叉 Huffman 树时，压缩效果明显更佳，而当选用$2^n+1$叉 Huffman 树时，压缩效果较差 ($2^n$叉 Huffman 树每一个节点都刚好可以利用 $n$ bit 的 Huffman 编码)\n    **因此，在压缩 txt 文本文件时，选用$2^n$叉 Huffman 树，在综合时间的情况下选择更大的压缩基本单元，能够提高压缩效率**\n    > 同时值得指出的是，对于图片，视频等文件类型，基本单元极有可能发生出现次数相近的情况，此时综合时间等考虑，可以尽量选择 1Byte 为压缩的基本单元\n\n### 十、源码\n&nbsp;&nbsp;&nbsp;&nbsp;[戳这里](https://github.com/voyage-li/huffman-compress)","tags":["huffman树"],"categories":["程序设计","C++","数据结构"]},{"title":"建站经历","url":"/2021/12/26/experience/","content":"\n本文将讲述我通过 hexo 以及 github page 建立本博客的过程\n\n### 一、本地环境\n\n- Ubuntu 20.04(wsl2)\n- hexo: 5.4.0\n- nodejs: v13.14.0(使用过高版本会出现警告)\n- npm: 6.14.4\n- 切换 node 版本:\n`bash\n    sudo n rm 16.13.1   # 删除指定版本node\n    sudo n 13.14.0      # 安装指定版本node\n    `\n<!--more-->\n\n### 二、初始化博客\n\n- 建立博客文件夹\n  ```bash\n  hexo init blog\n  ```\n- 输入以下指令之后可以在:[localhost:4000/](http://localhost:4000/)看到初始化的博客\n  ```bash\n  cd blog\n  hexo s\n  ```\n\n### 三、选择合适的主题\n\n&nbsp;&nbsp;&nbsp;&nbsp; 从[https://hexo.io/themes/](https://hexo.io/themes/)中选择合适的主题，本博客使用主题: [stun](https://github.com/liuyib/hexo-theme-stun)\n\n- 克隆主题项目到本地仓库\n  ```bash\n  git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n  ```\n- 安装 pug 引擎依赖\n  ```bash\n  npm install --save hexo-renderer-pug\n  ```\n- 将**博客文件目录**下的`_config.yml`中的 theme 内容改为 stun\n  ```yml\n  theme: stun\n  ```\n\n### 四、基本内容的设置\n\n#### 1. 基本操作\n\n```bash\nhexo new page filename  # 新建一个页面\nhexo new page tags      # 新建一个指定layout的页面，以标签tags为例\nhexo new articlename    # 新建一篇文章\nhexo clean              # 清除缓存文件\nhexo s                  # 本地渲染网站\nhexo d                  # 生成博客文件(后文具体详解)\n```\n\n#### 2. 修改博客基本信息\n\n- 修改**博客文件目录**下的`_config.yml`文件中的`title`,`subtitle`,`author`,`language`等\n- 修改**博客文件目录**下的`_config.yml`文件中的 url 为博客部署的地址(具体部署方法在后文)\n\n#### 3. 修改主题信息\n\n&nbsp;&nbsp;&nbsp;&nbsp;[stun 主题配置官方文件](https://theme-stun.github.io/docs/zh-CN/guide/primary.html)\n\n##### (1) 修改 menu 内容\n\n&nbsp;&nbsp;&nbsp;&nbsp;修改**主题文件目录**下的`_config.yml`文件 `||`左边为文件路径，右边为图标，具体不同图标选择见[Font Awesome](https://www.thinkcmf.com/font_awesome.html)\n\n````yml\nmenu:\nhome: / || fas fa-home\nabout: /about || fas fa-user\ncalculate: javascript:; || fas fa-database\nmessage: /message/ || fas fa-comment\nhistory: /history/ || fa fa-history\nfriends: /friend/ || fa fa-link\n\n    submenu:\n      calculate:\n        archives: /archives/ || fas fa-folder-open\n        categories: /categories/ || fas fa-layer-group\n        tags: /tags/ || fas fa-tags\n    ```\n\n&nbsp;&nbsp;&nbsp;&nbsp;自己添加的页面需要在主题文件夹下`/languages/zh-CN.yml`加入中文\n\n```yml\nmessage: 留言\n````\n\n##### (2) 修改网站 favicon\n\n&nbsp;&nbsp;&nbsp;&nbsp;生成头像见网站 [Favicon](https://realfavicongenerator.net/) 或者 [websiteplanet(更多的支持)](https://www.websiteplanet.com/webtools/favicon-generator/)\n\n```yml\nfavicon:\n  small: /images/icons/favicon-16x16.png\n  medium: /images/icons/favicon-32x32.png\n```\n\n##### (3) 修改 header 内容\n\n&nbsp;&nbsp;&nbsp;&nbsp;这里选择主页启用头部图，文章页面不显示头部图\n\n```yml\nheader:\n  enable: true\n  show_on:\n    post: false\n  height: 50%\n  bg_image:\n    enable: true\n    url: /images/icons/banner/saibo.jpg\n  mask:\n    enable: false\n    opacity: 0.5\n  nav:\n    height: 50px\n    bg_color: \"#333\"\n  scroll_down_icon:\n    enable: true\n    name: fas fa-angle-down\n    animation: true\n```\n\n##### (4) 修改侧边栏内容\n\n```yml\nsidebar:\n  enable: true\n  position: right\n  offsetTop: 20px\n  horizon_line: false\nauthor:\n  enable: true\n  avatar:\n    url: /images/icons/zoe.svg # 头像\n    rounded: true # 圆形\n    opacity: 1 # 透明度\n    animation: shake # (动画)\n  motto: \"每一天，每个季节都会过去， 然后就是新的开始\"\nsocial:\n  github: https://github.com/voyage-li/ || fab fa-github\n  twitter: https://twitter.com/_voy4ge_ || fab fa-twitter\n  email: mailto:voyage@mail.ustc.edu.cn || fa fa-envelope\n  qq: tencent://message?uin=923959605 || fab fa-qq\n```\n\n##### (5) 修改网页底部内容\n\n```yml\nfooter:\n  bg_image:\n    enable: false\n    url:\n  mask:\n    enable: false\n    opacity: 0.5\n  copyright:\n    enable: true\n    text:\n    since: 2021\n    end: 2022\n  icon:\n    enable: false\n    name: fas fa-heart\n    animation: false\n    color: \"#ff0000\"\n  powered:\n    enable: false\n    version: true\n  theme:\n    enable: false\n  beian:\n    enable: false\n    icp:\n  custom:\n    enable: false\n    text:\n```\n\n#### 4. 更多设置\n\n##### (1) 启用 Valine 评论\n\n```yml\nvaline:\n  enable: true\n  appid: # Your leancloud application appid.\n  appkey: # Your leancloud application appkey.\n  notify: true\n  verify: true\n  placeholder: 留下一句评论再走吧（请使用markdown语法）\n  avatar: monsterid\n  meta: nick,mail\n  pageSize: 10\n  visitor: true\n  language: zh-cn\n  enableQQ: true\n```\n\n##### (2) 启用 katex 渲染 latex 代码\n\n```yml\nmath:\n  enable: true\n  per_page: false\n  engine: katex\n```\n\n```bash\n# 如果安装以下插件，请全部卸载\nnpm un hexo-renderer-marked      --save\nnpm un hexo-renderer-kramed      --save\nnpm un hexo-renderer-pandoc      --save\nnpm un hexo-renderer-unified     --save\nnpm un hexo-renderer-markdown    --save\nnpm un hexo-renderer-markdown-it --save\nnpm un hexo-math                 --save\nnpm un hexo-inject               --save\n# 安装新的渲染器\nnpm i hexo-renderer-markdown-it-plus --save\n```\n\n##### (3) 启用 Quicklink 提前加载\n\n```yml\nquicklink:\n  enable: true\n  home: true\n  archive: true\n  delay: true\n  timeout: 10000\n  priority: true\n  ignores:\n    - /\\/api\\/?/\n    - uri => uri.includes('.xml')\n    - uri => uri.includes('.zip')\n    - (uri, el) => el.hasAttribute('nofollow')\n    - (uri, el) => el.hasAttribute('noprefetch')\n```\n\n##### (4) 启用 pjax 平滑跳转\n\n```yml\npjax:\n  enable: true\n  elements:\n  selectors:\n  switches:\n  switchesOptions:\n  history: true\n  scrollTo: 0\n  scrollRestoration: true\n  cacheBust: false\n  debug: false\n  currentUrlFullReload: true\n  timeout: 0\n```\n\n##### (5) 启用本地搜索\n\n&nbsp;&nbsp;&nbsp;&nbsp;安装插件\n\n```bash\nnpm install hexo-generator-search --save\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;在**博客文件目录**下的`.config.yml`加入\n\n```yml\nsearch:\n  path: search.json\n  field: post\n  content: true\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;修改**主题文件目录**下的`.config.yml`\n\n```yml\nlocal_search:\n  enable: true\n```\n\n##### (6) 启用 fancybox\n\n```yml\nfancybox: true\n```\n\n##### (7) 代码块\n\n```yml\ncodeblock:\n  style: carbon\n  highlight: light\n  word_wrap: false\n```\n\n### 五、自主修改\n\n#### 1. 启用 live2d 看板娘\n\n- 下载依赖:[https://github.com/EYHN/hexo-helper-live2d](https://github.com/EYHN/hexo-helper-live2d)\n  ```bash\n  npm install --save hexo-helper-live2d\n  ```\n- 选择下载自己喜欢的 model:[https://github.com/xiazeyu/live2d-widget-models](https://github.com/xiazeyu/live2d-widget-models)\n\n  ```bash\n  npm install live2d-widget-model-hijiki\n  ```\n\n- 在**博客文件目录**下的`.config.yml`加入\n  ```yml\n  live2d:\n    enable: true\n    pluginModelPath: assets/\n    model:\n      use: live2d-widget-model-hijiki #模板目录，直接更换名字即可\n    display:\n      position: left\n      width: 170\n      height: 250\n    mobile:\n  show: false\n  ```\n\n#### 2. 添加告示栏\n\n&nbsp;&nbsp;&nbsp;&nbsp;将原来的 sidebar 的 div 内部再加上一个 div\n\n- sidebar.pug 加入(~~渲染不了 pug，有时间改~~)\n  ```pug\n  - var notice_content=theme.sidebar.notice.content\n  - var iconClass=theme.sidebar.notice.icon\n  if page.notice !== false && theme.sidebar.notice.enable\n    div.notice\n      span.notice_banner\n          i(class=iconClass)\n      span.notice_banner=\" NOTICE\"\n      br\n      notice_text.notice_text=notice_content\n  ```\n- **主题文件目录**下的`.config.yml`的 sidebar 内加入\n  ```yml\n  notice:\n    icon: fa fa-bell\n    enable: true\n    content: \"反复刷新界面可能导致部分js失\n  ```\n\n#### 3. 深色模式不同 banner 图\n\n- **主题文件**加入图片地址\n- styl 文件直接加入样式\n  ```styl\n  .nightmode .header-banner\n  {\n      position: relative;\n      z-index: 0;\n      width: 100%;\n      height: 100%;\n      if (hexo-config('header.bg_image.enable') && hexo-config('header.bg_image.url')) {\n        background: url(hexo-config('header.bg_image.night_url')) no-repeat center / cover;\n      }\n  }\n  ```\n\n### 六、部署\n\n- 安装依赖\n  ```bash\n  npm install hexo-deployer-git --save\n  ```\n- **博客文件目录**下`.config.yml`加入\n  ```yml\n  deploy:\n    type: git\n    repository: git@github.com:voyage-li/voyage-li.github.io.git\n    branch: main\n  ```\n- 部署\n  ```bash\n  hexo clean && hexo g && hexo d\n  ```\n\n### 七、后记\n\n- Thanks <amandagut.94@gmail.com> for your help\n","tags":["hexo","npm"]},{"title":"C++图形化扫雷","url":"/2021/08/16/mine-sweep/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;扫雷主体部分的c++代码实现，以及Qt的简单介绍，并且通过Qt来实现扫雷游戏的图形化，鼠标点击时间的判断，信号与槽的使用，以及游戏难度的选择以及自定义和记录时间功能的添加。\n\n### 一、主体函数的C++实现\n\n#### \t1.游戏的初始化\n\n最简单的扫雷游戏是一个9×9的方块，因此，我们可以建立一个9×9的二维数组，先对其进行初始化，然后，在其中存储相关的数据。\n```c++\n#define ROW 9\n#define COL 9\nint gamedata[ROW][COL]; //记录原始数据\nmemset(gamedata, 0, sizeof(gamedata));\n```\n不同状态的记录，扫雷游戏每一个小块的状态可以对应表示成的不同的数字。\n\n```c++\n//0~8 该方块周围的雷的数量\n//88 该方块为雷\n//777 该方块处于待点击状态\n```\n<!--more-->\n雷的生成，简单的扫雷游戏中，会在9×9的81方块中随机生成10个雷，转化成计算机的语言就是，从1\\~81中任意取10个数，但是这样的选取有一定的缺点，在我们取出随机数之后，我们很难将随机数与相应的雷产生联系，带来了不必要的麻烦，解决方案是，我们可以生成十组横纵坐标1\\~9之间的随机数（避免重复的情况），这样下来，随机数的选取和雷的位置对应能够更加的简单，代码实现如下：\n\n```c++\n#define BOOM_NUM 10\nint boom_num_now = 0; //已经生成的雷的数量\nwhile (boom_num_now != BOOM_NUM)\n{\n    //这里随机数使用了QRandomGenerator头文件中的函数\n    int x=QRandomGenerator::global()->bounded(0,ROW);   \n    int y=QRandomGenerator::global()->bounded(0,COL);\n    if (gamedata[x][y] == 88)\n        continue;\n    else\n        gamedata[x][y] = 88;\n    boom_num_now++;\n}\n```\n每一个方块周围雷数量的统计，通过一个循环来计数即可：\n```c++\nint tmp;\nfor (int i = 0; i < ROW; i++)\n    for (int j = 0; j < COL; j++)\n    {\n        tmp = 0;\n        if (gamedata[i][j] == 88)\n            continue;\n        for (int dx = i - 1; dx <= i + 1; dx++)\n            for (int dy = j - 1; dy <= j + 1; dy++)\n            {\n                if (dx >= 0 && dy >= 0 && dx < ROW && dy < COL && gamedata[dx][dy] == 88)\n                     tmp++;\n             }\n         gamedata[i][j] = tmp;\n     }\n```\n\n生成一个向玩家展示的数组，来记录每一点击产生的结果，如下所示：\n\n```c++\nint view[ROW][COL];\nfor (int i = 0; i < ROW; i++)\n    for (int j = 0; j < COL; j++)\n        view[i][j] = 777;\n```\n\n#### 2.鼠标点击事件的判断\n\n鼠标点击一个方块，即选择了对应左边的数据，如果选中了雷，那么游戏结束，如果选中了其他方块，则需要判断其周围有没有雷，以此来翻开其它的方块，其本质是一个深度搜索(`DFS`)，我们可以通过递归来完成这个过程，具体的思想是：\n\n先通过循环判断点击方块一周的方块是否有雷，如果没有雷的话，就相当于我们点击了周围一圈的方块，可以直接递归调用该函数，递归返回的条件分为两种，一种是该方块已经翻开，一种是该方块周围有雷的存在，具体的代码实现如下所示：\n\n```c++\nvoid dfs(int x, int y)\n{\n    int flag = 0;\n    if (view[x][y] != 777)\n        return;\n    view[x][y] = gamedata[x][y];\n    for (int dx = x - 1; dx <= x + 1; dx++)\n        for (int dy = y - 1; dy <= y + 1; dy++)\n        {\n            if (dx >= 0 && dx < ROW && dy >= 0 && dy < COL)\n                if (gamedata[dx][dy] == 88)\n                {\n                    flag = 1;\n                    break;\n                }\n        }\n    if (flag == 0)\n    {\n        for (int dx = x - 1; dx <= x + 1; dx++)\n            for (int dy = y - 1; dy <= y + 1; dy++)\n                if (dx >= 0 && dx < ROW && dy >= 0 && dy < COL)\n                    dfs(dx, dy);\n    }\n}\n```\n\n#### 3.游戏胜利的条件判断\n\n扫雷游戏的胜利条件判断较为简单，如果剩余的没有点击的方块数量（没有点击或者已经被标记）和雷数相同，就表示游戏取得了胜利，代码实现如下：\n\n```c++\nbool whetherwin()\n{\n    int temp = 0;\n    for (int i = 0; i < ROW; i++)\n        for (int j = 0; j < COL; j++)\n        {\n            if (view[i][j] == 777)\n                temp++;\n        }\n    if (temp == BOOM_NUM)\n        return true;\n    else\n        return false;\n}\n```\n\n至此，就完成了整个扫雷游戏的主体函数部分，再加上输入输出函数，和一些额外条件的判断，就可以得到一个基本的命令行版本的扫雷游戏。\n\n### 二、从C++过渡到Qt\n\n#### 1.窗口的搭建\n\n打开Qt creator,新建一个Qt Widgets Application，点击mainwindow.ui进入设计界面，通过拖动左栏的窗口控件，完成图形化窗口的搭建。\n\n#### 2.扫雷界面的绘制\n\n`QPixmap`头文件中主要用来绘图的函数是`drawPixmap()`,根据Qt官方文档的描述，`drawPixmap()`,有多种重载函数，由于为扫雷游戏准备的资源文件已经是确定了像素的，只需要对绘图的位置和不同的图片进行选择，所以选择以下所示的重载函数。\n\n```c++\ninline void QPainter::drawPixmap(int x, int y, const QPixmap &pm)// x,y表示需要绘图位置的坐标，pm是需要绘制的图片{    drawPixmap(QPointF(x, y), pm);}\n```\n\n使用循环，在`paitEvent()`内调用`drawPixmap()`函数即可绘制主要的窗口：\n\n```c++\n#define BLOCK_HEIGHT 30\n#define BLOCK_WIDTH 20\n#define MENU_WIDTH 26+40\nQPainter painter(this);for (int i = 0; i < ROW; i++)\n{    \n    for (int j = 0; j < COL; j++)        \n        painter.drawPixmap(i * BLOCK_HEIGHT, MENU_WIDTH + j * BLOCK_WIDTH, view[i][j]);\n}\n```\n\n#### 3.鼠标点击事件的具体实现\n\n根据Qt官方文档，和鼠标点击相关的头文件是`QMouseEvent`，官方文档内，对获取鼠标点击位置的描述函数是：\n\n```c++\ninline int x() const { return qRound(l.x()); }\ninline int y() const { return qRound(l.y()); }\n```\n\n这样得到的位置坐标是对应的像素坐标，我们知道每一个方块的边长，通过取余数的方式可以获得具体的在扫雷游戏中的坐标\n\n```c++\nint x = event->x() / BLOCK_WIDTH;\nint y = (event->y() - MENU_WIDTH) / BLOCK_HEIGHT; //需要剪掉菜单栏的距离\n```\n\n在实际游戏时，鼠标左右键点击的效果不同，`QMouseEvent`中对鼠标点击事件的描述是\n\n```c++\ninline Qt::MouseButton button() const { return b; }\n```\n\n该函数会返回一个枚举类型，对应着不同的鼠标点击，具体的实现如下：\n\n```c++\nif (event->button() == Qt::LeftButton) {}\nelse if (event->button() == Qt::RightButton) {}\n```\n\n#### 4.点击数字功能实现\n\nWindows平台的扫雷游戏中，用户可以点击已被翻开的数字方块，如果周围所有的雷已被标记，则可以直接翻开未被标记的方块，如果标记雷的数量是正确的，但是标记的具体方块是错误的，则会直接导致游戏结束，如果已经标记的雷的数量和点击数字方块的数字不同，则直接等待下一次用户的操作。\n\n实现该功能的思路是，先判断鼠标左键点击的位置，得到该方块周围雷的数量，然后循环周围已经被标记的雷的数量，以及标记的是否正确，如果标记错误，则可以直接触发游戏结束命令，如果标记正确且和对应的雷数量相同，则调用上文已经叙述过的`dfs()`函数，翻开方块，代码的具体实现如下所示：\n\n```c++\nelse if (event->button() == Qt::LeftButton && mine->view[x][y] != 777 && mine->view[x][y] != -1)\n{    \n    int aim = mine->view[x][y];    \n    int temp_flag = 0;    \n    int error = 0;    \n    for (int dx = x - 1; dx <= x + 1; dx++)        \n        for (int dy = y - 1; dy <= y + 1; dy++)            \n            if (dx >= 0 && dx < mine->getrow() && dy >= 0 && dy < mine->getcolumn())            \n            {               \n                if (mine->view[dx][dy] == -1 && mine->gamedata[dx][dy] != 88)                    \n                    error = 1;                \n                if (mine->view[dx][dy] == -1)                \n                {                    \n                    temp_flag++;\n                }            \n            }    \n    if (temp_flag == aim)    \n    {        \n        if (error == 1)        \n        {            \n            gameover = true;            \n            runtime->stop();            \n            gamestart = 1;            \n            alreadyflag = 0;            \n            for (int i = 0; i < mine->getrow(); i++)                \n                for (int j = 0; j < mine->getcolumn(); j++)                \n                {                    \n                    if (mine->view[i][j] == -1 && mine->gamedata[i][j] != 88)                        \n                        mine->gamedata[i][j] = -777;                \n                }            \n            repaint();            \n            return;        \n        }        \n        for (int dx = x - 1; dx <= x + 1; dx++)            \n            for (int dy = y - 1; dy <= y + 1; dy++)                \n                if (dx >= 0 && dx < mine->getrow() && dy >= 0 && dy < mine->getcolumn())                \n                {                    \n                    if (mine->view[dx][dy] == 777)                    \n                    {                        \n                        dfs(dx, dy);                        \n                        repaint();                    \n                    }                \n                }    \n    }\n}\n```\n\n#### 5.程序的执行步骤\n\n- 用户开始选择开始游戏，程序自动产生两个数组：`gamedata`和`view`\n- 程序自动给`gamedata`进行初始化，`view`的值则全部设置成为UNKNOWN，即尚未打开状态，程序根据数组`view`，将当前的游戏状态通过`drawPixmap()`绘制到窗口上\n- 用户点击窗口，触发`QMouseEvent`，进入函数进行相应的判断，根据鼠标的左右键点击的不同，进入不同的分支\n- 同时每次触发完鼠标点击时间之后，都进行一次是否获胜的判断。同时，定义`bool`类型的全局变量`gameover`，如果游戏已经失败或者已经z取胜，则将`gameover`设置为true，不再进入鼠标点击时间的判断。\n\n### 三、额外功能的实现\n\n#### 1.不同难度的选择和自定义\n\n- 传统扫雷游戏可以选择不同的难度，此次实现的扫雷游戏应该也有这个功能。为了实现这一功能，可以定义一个`block`类，以此来储存不同情况下的横宽以及雷的数量，同时，由于不同的情况下，`gamedata`和`view`的初始化不同，所以游戏的初始化也应该放在`block`类中完成。\n- `block`类中主要定义了：扫雷游戏的长，扫雷游戏的高，扫雷游戏雷的数量，当前已经经过的时间。同时上述的成员均为`private`成员，所以同时需要定义`public`的成员函数，来一一对应，获得上述对象的值。\n\n- 在整个游戏开始时，先建立一个`block`类的指针，其中第一次进入消息循环时，使用初级难度作为初始化的值、在用户选择不同难度的时侯，可以通过传给指针不同的地址，来进行处理。\n\n- 首先类需要处理的是游戏的初始化，由于需要根据类的构造函数来创建数组，所以显然需要动态申请内存空间，这里可以在类中定义二维指针，然后通过`new`来动态开辟内存空间，具体实现如下（这里只展示其中一个数组的初始化方法，另外一个数组的初始化方法完全相同）：\n\n    ```c++\n    view = new int *[row];for (int i = 0; i < row; i++)    \n        view[i] = new int[column];\n    for (int i = 0; i < row; i++)    \n        for (int j = 0; j < column; j++)    \n        {        \n            gamedata[i][j] = 0;        \n            view[i][j] = 777;    \n        }\n    ```\n\n- 实现用户自定义游戏难度即是要接收用户输入的数据，可以通过新建一个窗口来接收数据，但在接收数据的途中，需要注意用户输入数据的合理性。行和列数不能为负或者过大，以及用户输入的雷的数量不能多于用户输入的行列数乘积，否则会造成非法访问的问题，导致程序异常退出。\n\n#### 2.剩余雷数量的计算以及呈现\n\n全局变量`alreadyflag`来记录已经被鼠标左键标记的雷的数量，同时每次检测到鼠标左键点击的时候，根据情况的不同，即时更改，同时，在每轮游戏结束时，将`alreadyflag`变量重新初始化。\n\n雷的数量的绘制也应写在`paintEvent()`内部，获得剩余雷的数量之后，使用分支语句，直接将数字呈现给用户。需要注意的是，为了防止用户标记的雷的数量超过游戏本生雷的数量，所以在绘制前需要判断是否剩余未标记雷的数量为负值\n\n#### 3.游戏时间记录与绘制\n\nQt中与时间有关的头文件主要有`QTimer`，新建一个`QTimer`对象，通过调用`start()`函数控制Qt计时器的开始以及时间间隔，通过`connect()`函数，连接`timeout()`信号与自定义的槽函数，随着时间的变化执行相应的不同操作。\n\n记录时间变化的槽函数可以使用`block`类的成员函数，在`block`类中初始化一`private`类型的时间变量，每次调用槽函数使该变量递增，即可记录当前时间，具体的代码实现如下：\n\n```c++\n//mainwindow.cppblock \n*mine = new block(ROW, COLUMN, BOOM_NUM);runtime = new QTimer(this);connect(runtime, SIGNAL(timeout()), this, SLOT(on_secondadd()));connect(runtime, SIGNAL(timeout()), this, SLOT(update()));\nvoid MainWindow::on_secondadd()\n{   \n    mine->addtime();\n}\n//block.cppvoid block::addtime(){    time_now++;}//时间绘制部分与雷数量呈现部分相同\n```\n\n### 四、源码及素材来源\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[源码](https://github.com/voyage-li/mine_sweep)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[扫雷图片素材来源](https://github.com/fengqian-wei/qt-mine-sweeping)\n\n","tags":["GUI","Qt","DFS"],"categories":["游戏","程序设计","扫雷","C++"]},{"title":"MC红石特效的原理","url":"/2021/07/18/MC-RED/","content":"\n简单的讲一下红石特效制作的方法（教学向，不涉及各种材质包的添加什么的，尽量保证看文章之后能在mc里面用特效画出直线，曲线）\n<!--more-->\n### 一、教学环境\n- 版本: 1.12.2(java版)\n- Fabric: 不安装\n- Forge: 14.23.5.2855\n- ~~不怎么清晰的头脑和不怎么协调的手~~\n\n### 二、前置知识\n- MC的基础操作（这个不用教吧）\n- 简单的任何高级语言的使用\n- mcfunction的介绍\n    - 在你的游戏存档下有这样一个文件夹`./data/functions/`，在其中你可以新建文件夹，同时在里面写一些后缀为`.mcfunction`的文件，在游戏中就可以调用内部的函数\n- 然后，然后我们就可以开始了！\n\n### 三、生成粒子\n粒子的生成需要用到particle命令\n\n```bash\nparticle <粒子名称> <x> <y> <z> [<xd> <yd> <zd>] [飞行速度] [粒子数量] [显示模式] [目标玩家]\n```\n{% note danger no-icon %}\nmc里面的坐标和我们平常感觉的存在着点差异！\n{% endnote %}\n上面讲的有点复杂，简单来说\n```bash\nparticle endRod x y z 0 0 0 0 1 force//在（z,y,x）处生成一个静止的endRod粒子\nparticle endRod x y z vx vy vz r 0 force//在（z,y,x）处生成一个endRod粒子，大小为r,速度方向由vx,vy,vz决定\n```\n到这里，其实你就已经可以在游戏里面生成了一个点了，如果你只是想知道原理，那现在，你就可以走了，再接下来的简单来说就是不断调用这个指令了。\n\n### 四、生成直线\n- 实现\n我们已经学会了生成一个粒子了，那么很自然的我们就可以想到，只要生成连续的多个粒子，就可以获得直线\n但是命令方块只能调用一次函数，怎么样才能够同时调用多个函数呢，这里我们就要用到刚才说的mcfunction了，在functions文件夹里面新建一个文件夹（我命名为draw），在其中新建一个文件line.mcfunction，这时候，我们就可以在其中进行编辑\n空间中直线的参数方程:\n$$\n    \\left\\{\n        \\begin{aligned}\n            x = x_0+v_xT \\\\\n            y = y_0+v_yT\\\\\n            z = z_0+v_zT\n        \\end{aligned}\n    \\right.\n$$\n- 然后就可以直接根据循环来描点了\n\t```c++\n//具体参数要改\n#include <bits/stdc++.h>\nint main()\n{\n    float x1, y1, z1, x2, y2, z2;\n    std::cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    for (int i = 0; i <= 100; i++)\n    {\n        float x, y, z;\n        x = x1 + ((x2 - x1) * i) / (100);\n        y = y1 + ((y2 - y1) * i) / (100);\n        z = z1 + ((z2 - z1) * i) / (100);\n        std::cout << \"particle fireworksSpark \" << x << \" \" << y << \" \" << z << \" 0 0 0 0 1 force\" << std::endl;\n    }\n    return 0;\n}\n```\n- 游戏内具体调用\n    ```bash\n$ reload # 每次重写文件之后需要重新载入文件内容\n$ function draw:line # 调用函数\n```\n\n### 五、生成抛物线\n和直线一样，写出参数方程，直接穷举就行了\n$$\n\\left\\{\n\\begin{array}{l}\nx = x_0+v_xT \\\\\ny = y_0+v_yT\\\\\nz = z_0+v_zT-\\frac{1}{2}gT^2\n\\end{array}\n\\right.\n$$\n代码就很简单了，(~~自己写的太乱了,不贴出来了~~)\n\n### 六、其他曲线\n- 只要你能写出曲线的参数方程，你就可以轻松的通过循环，得到描绘该曲线的mcfunction代码，这里就不做过多的赘述了\n- 当然只要你愿意，你甚至可以不需要参数方程，直接通过穷举描绘图线\n\n### 七、关于图像\n![mc02.png](https://s2.loli.net/2021/12/28/DQwyp2BG96mYaoz.png)\n使用python，具体参数可以自己调\n{% note default no-icon %}\n刚开始写红石特效的时候对python一窍不通，这个也是根据别人写的改的\n{% endnote %}\n```python\nfrom PIL import Image\nim = Image.open('<填入你图片的名字>.png')\nf = open(r'iamge.mcfunction', \"w\")\nx, y, z = 0, 0, 0\ndirection = 'z'\nzoom_level = 30\nparticle_name = \"endRod\"\nparticle_value = \"0 0 0 0 1 force\"\nwidth, height = im.size[0], im.size[1]\nfor w in range(0, width):\n    for h in range(0, height):\n        imgdata = (im.getpixel((w, h)))\n        if imgdata[0] == 0:\n            if direction == 'z':\n                cmd = f'particle {particle_name} {x-w/zoom_level} {y-h/zoom_level} {z} {particle_value}'\n                f.write(f'{cmd}\\n')\n            elif direction == 'y':\n                cmd = f'particle {particle_name} {x - w / zoom_level} {y} {z - h / zoom_level} {particle_value}'\n                f.write(f'{cmd}\\n')\n            elif direction == 'x':\n                cmd = f'particle {particle_name} {x} {y - h / zoom_level} {z - w / zoom_level} {particle_value}'\n                f.write(f'{cmd}\\n')\nf.close()\n```\n\n### 八、补充\n到这里，其实还有一个没有解决的问题：如何先后呈现红石特效\n~~根据自己电脑性能自己看看一个区间花多少个点就行了~~\n\n其实很简单，摆两行命令方块，中间空一行，上面一行命令方块，写入想要执行的指令，下面一行写入\n```bash\nclone ~ ~1 ~ ~ ~1 ~ ~1 ~1 ~ replace move # 注意修改方向\n```\n![mc04.png](https://s2.loli.net/2021/12/28/OqQxtkJL9Al3o8f.png)\n\n这样，我们在中间放上红石块，红石块触发上下两个命令方块，而触发了下面的命令方块，又会将命令方块向前移动一格，从此先后触发不同的效果\n\n如果同一个时间触发多个效果，~~就上多个线程~~，多几个这样的命令方块轨道就行了\n\n### 九、比较垃圾的展示\n- 依托于worldedit实现红石音乐与红石特效的简单结合\n![mc05.png](https://s2.loli.net/2021/12/28/VCeA4MQvb8yZLnX.png)\n- 比较水的红石特效\n![mc06.png](https://s2.loli.net/2021/12/28/gOBx4MnzNrVYECW.png)\n- 祝曾经某个很可爱的朋友(不用怀疑，就是没有声音)\n<video src='/images/mc/bir.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'>\n</video>\n\n### 十、后记\n- 可以使用自制的粒子来达到更好的效果\n- 加材质包，加光影，加材质包，加光影\n- 红石特效原理其实很简单，但是它的难点不在其实现上，而在于创新\n- 本人对红石特效仍处于摸索阶段，如果有说的不对的地方欢迎联系\n","tags":["mcfunction"],"categories":["游戏","minecraft"]},{"title":"Markdown转Html","url":"/2021/07/15/md-html/","content":"> **程序设计二 大作业**\n\n&nbsp;&nbsp;&nbsp;&nbsp;设计一款软件可以把markdown语言转化成HTML语言。即输入markdown语言，软件输出HTML语言。软件需要将GFM规范中常用到的Text，Headers，List，Images，Links五项内容转化成HTML语言。从用户的角度出发，还要拥有GUI\n\n\n### 一、设计思路\n- 打开文件(判断是否为markdown文件)\n- 读取文件全部内容\n- 输出html标签\n- 选择写入的css样式\n- 主题转换部分使用正则表达式\n- 输出固定的结尾\n<!--more-->\n### 二、转换方法\n\n#### 1. Text\n需要转化的正文部分有加粗，斜体，删除线，简单单行代码块，高亮\n以加粗为例，则需要完成的转化为:\n$$\n**info** \\  \\Rightarrow \\  <b>info</b>\n$$\n转换时使用正则表达式(s为代转换字符串):\n```c++\nstd::string temp, temp2;\nstd::regex re_b(\"\\\\*\\\\*([^\\\\*\\\\*]+)\\\\*\\\\*\");\ntemp = s;\nstd::regex_replace(std::back_inserter(temp2), temp.begin(), temp.end(), re_b, \"<b>$1</b>\");\ns = temp2;\n```\n依次可完成加粗的转换，下面给出不同格式的正则表达式\n```c++\nstd::regex re_i1(\"\\\\*([^\\\\*]+)\\\\*\");            //斜体\nstd::regex re_i2(\"\\\\_([^\\\\_]+)\\\\_\");            //斜体\nstd::regex re_S(\"\\\\~\\\\~([^\\\\~\\\\~]+)\\\\~\\\\~\");    //删除线\nstd::regex re_b1(\"\\\\*\\\\*([^\\\\*\\\\*]+)\\\\*\\\\*\");   //加粗\nstd::regex re_b2(\"\\\\_\\\\_([^\\\\_\\\\_]+)\\\\_\\\\_\");   //加粗\nstd::regex re_code(\"\\\\`([^\\\\`]+)\\\\`\");          //简单代码块\nstd::regex re_mark(\"\\\\=\\\\=([^\\\\=\\\\=]+)\\\\=\\\\=\"); //高亮显示\n```\n\n#### 2. Headers\n需要完成的转换为:\n$$\n\\underbrace{\\#\\#\\cdots}_{n}\\ \\ text \\Rightarrow \\  <hn>text</hn>\n$$\n所以需要先统计'#'出现的次数，再进行转换:\n```c++\nvoid tr_head(std::string s)\n{\n    int index = 0;\n    while (s[index] == '#')\n        index++;\n    std::smatch answer;\n    std::regex_match(s, answer, std::regex(\"^#{1,6} (.+)$\"));\n    std::cout << \"<h\" << index << \">\" << answer[1] << \"</h\" << index << \">\" << std::endl;\n}\n```\n\n#### 3. Images\n需要完成的转换\n$$\n![name](url) \\  \\Rightarrow \\ <img\\ \\ src=``url\">\n$$\n转换方法同前面类似，下面给出识别的正则表达式\n```c++\nstd::regex re_image(\"!\\\\[.+\\\\]\\\\((.+)\\\\)\");\n```\n#### 4. Links\n需要完成的转换\n$$\n[name](url) \\  \\Rightarrow \\ <a\\ \\ href=``url\">name</a>\n$$\n直接给出正则表达式\n```c++\nstd::regex re_image(\"\\\\[.+\\\\]\\\\((.+)\\\\)\");\n```\n#### 5. Lists\n- 整个翻译开始前先进行列表的递归搜索\n- 先判断是否是列表，然后返回一个奇数或者偶数来代表判断返回的是有序列表还是无序列表，同时该数据还能储存空行数\n- 若是列表，则判断与上一级的前面空格的关系，判断是否是新的一级列表，进入下一次递归，若上一级列表已经结束，则回溯到同一级列表处\n- 整个列表结束时，返回，输出结尾的`</ol>`或则和`</ul>`，结束递归\n\n具体的代码如下\n```c++\nint islist(int i)//判断是否为列表\n{\n    int index = 0;\n    std::regex a(\"^[ ]*[-*+] (.+)$\");\n    std::regex e(\"^[ ]*\\\\d+[.] (.+)$\");\n    if (std::regex_search(content[i], e))\n    {\n        for (int j = 0; content[i][j] == ' '; j++)\n            index++;\n        if (index % 4 == 0)\n            content[i] = std::regex_replace(content[i], e, \"<li>$1</li>\");\n        else\n            return -1;\n        return 2 * index;\n    }\n    else if (std::regex_search(content[i], a))\n    {\n        for (int j = 0; content[i][j] == ' '; j++)\n            index++;\n        if (index % 4 == 0)\n            content[i] = std::regex_replace(content[i], a, \"<li>$1</li>\");\n        else\n            return -1;\n        return 2 * index + 1;\n    }\n    else\n        return -1;\n}\nint blankjudge(int a)//判断空格无序还是有序\n{\n    if (a % 2 == 0)\n        return a / 2;\n    else\n        return (a - 1) / 2;\n}\nint handlelist(int i, int blanklast)\n{\n    now = i;\n    int blankthis = islist(i);\n    if (blankthis == -1)\n        return -1;\n    else\n    {\n        int blankthis_temp = blankjudge(blankthis);\n        int blanklast_temp = blankjudge(blanklast);\n        if (blankthis % 2 == 0)\n        {\n\n            if (blankthis_temp > blanklast_temp || (blankthis_temp == blanklast_temp && blankthis != blanklast))//新的一层列表\n            {\n                content[i].insert(0, \"<ol>\");\n                int tmp = handlelist(i + 1, blankthis);\n                if (tmp == blankthis_temp)\n                    tmp = handlelist(now + 1, blankthis);\n                content[now - 1] += \"</ol>\";\n                return tmp;\n            }\n            else if (blankthis_temp == blanklast_temp && blankthis == blanklast)//和上级相同\n            {\n                int tmp = handlelist(i + 1, blankthis);\n                return tmp;\n            }\n            else//上一级列表结束\n                return blankthis_temp;\n        }\n        else//同理\n        {\n            if (blankthis_temp > blanklast_temp || (blankthis_temp == blanklast_temp && blankthis != blanklast))\n            {\n                content[i].insert(0, \"<ul>\");\n                int tmp = handlelist(i + 1, blankthis);\n                if (tmp == blankthis_temp)\n                    tmp = handlelist(now + 1, blankthis);\n                content[now - 1] += \"</ul>\";\n                return tmp;\n            }\n            else if (blankthis_temp == blanklast_temp && blankthis == blanklast)\n            {\n                int tmp = handlelist(i + 1, blankthis);\n                return tmp;\n            }\n            else\n                return blankthis_temp;\n        }\n    }\n    return 0;\n}\n```\n#### 6. Quote\nquote的转化和list基本相同，同时免去了有序无序的判断\n```c++\nint isquote(int i)\n{\n    std::regex a(\"^\\\\>+(.+)$\");\n    if (std::regex_match(content[i], a))\n    {\n        int index = 0;\n        while (content[i][index] == '>')\n            index++;\n        content[i] = std::regex_replace(content[i], a, \"<p>$1</p>\");\n        return index;\n    }\n    else\n        return 0;\n}\nvoid handlequote(int i, int last)\n{\n    now = i;\n    int number = isquote(i);\n    if (number == 0)\n        return;\n    else if (number >= last)\n    {\n        for (int j = 0; j < number - last; j++)\n            content[i].insert(0, \"<blockquote>\");\n        handlequote(now + 1, number);\n        for (int j = 0; j < number - last; j++)\n            content[now - 1] += \"</blockquote>\";\n    }\n}\n```\n#### 7. 分割线\n较为简单，直接给出转换函数\n```c++\nif (std::regex_search(s.at(i), std::regex(\"^\\\\-{3,}$\")))\n    printf(\"<hr/>\\n\");\nif (std::regex_search(s.at(i), std::regex(\"^\\\\*{3,}$\")))\n    printf(\"<hr/>\\n\");\n```\n\n### 三、GUI的实现\n依托Qt实现程序的图形化，相关内容可查看源码\n\n### 四、实验感想\n- 学习了markdown及html相关语法\n- 熟悉了正则表达式的使用\n- 熟悉了c++图形化界面的设计\n\n### 五、源码\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[戳这里](https://github.com/voyage-li/markdown-html)","tags":["正则表达式","GUI","Qt"],"categories":["程序设计","C++"]}]